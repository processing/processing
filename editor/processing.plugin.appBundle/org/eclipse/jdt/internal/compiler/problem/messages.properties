###############################################################################
# Copyright (c) 2000, 2008 IBM Corporation and others.
# All rights reserved. This program and the accompanying materials
# are made available under the terms of the Eclipse Public License v1.0
# which accompanies this distribution, and is available at
# http://www.eclipse.org/legal/epl-v10.html
#
# Contributors:
#     IBM Corporation - initial API and implementation
###############################################################################
0 = {0}
1 = super cannot be used in java.lang.Object
2 = {0} cannot be resolved to a type
3 = The type {0} is not visible
4 = The type {0} is ambiguous
5 = The type {0} is deprecated
6 = The nested type {0} cannot be referenced using its binary name
7 = The type {0} is never used locally

15 = Incompatible operand types {0} and {1}
16 = Incompatible conditional operand types {0} and {1}
17 = Type mismatch: cannot convert from {0} to {1}
18 = The static member type {0}.{1} should be accessed directly

20 = No enclosing instance of type {0} is accessible to invoke the super constructor. Must define a constructor and explicitly qualify its super constructor invocation with an instance of {0} (e.g. x.super() where x is an instance of {0}).
21 = No enclosing instance of type {0} is accessible. Must qualify the allocation with an enclosing instance of type {0} (e.g. x.new A() where x is an instance of {0}).
22 = No enclosing instance of the type {0} is accessible in scope
23 = Illegal enclosing instance specification for type {0}
24 = Cannot define static initializer in inner type {0}
25 = Cannot refer to a non-final variable {0} inside an inner class defined in a different method
26 = The member interface {0} can only be defined inside a top-level class or interface
27 = Cannot use an expression of the type {0} as a valid enclosing instance
28 = No enclosing instance of type {0} is available due to some intermediate constructor invocation
29 = An anonymous class cannot subclass the final class {0}
30 = The member annotation {0} can only be defined inside a top-level class or interface
31 = The member enum {0} cannot be local
32 = The member enum {0} must be defined inside a static member type
33 = The type {0} is hiding the type {1}

50 = {0} cannot be resolved
51 = The local variable {0} may not have been initialized
52 = void is an invalid type for the variable {0}
###[obsolete] 53 = An array of void is an invalid type for the variable {0}
54 = void[] is an invalid type
55 = Duplicate local variable {0}
56 = Duplicate parameter {0}
57 = The final local variable {0} may already have been assigned
58 = The final local variable {0} cannot be assigned. It must be blank and not using a compound assignment
59 = The parameter {0} should not be assigned
60 = The final local variable {0} cannot be assigned, since it is defined in an enclosing type
61 = The local variable {0} is never read
62 = The parameter {0} is never read
63 = The code of method {0}({1}) is exceeding the 65535 bytes limit
64 = The code for the static initializer is exceeding the 65535 bytes limit
65 = Too many parameters, parameter {0} is exceeding the limit of 255 words eligible for method parameters
66 = Too many local variables, local variable {0} is exceeding the limit of 65535 words eligible for method local variables
67 = Too many synthetic parameters, emulated parameter {0} is exceeding the limit of 255 words eligible for method parameters
68 = Too many array dimensions. Maximum is 255
69 = The code of constructor {0}({1}) is exceeding the 65535 bytes limit
70 = {0} cannot be resolved or is not a field
71 = The field {1}.{0} is not visible
72 = The field {0} is ambiguous
73 = The field {0}.{1} is deprecated
74 = Cannot make a static reference to the non-static field {0}
75 = Cannot reference a field before it is defined
76 = The static field {0}.{1} should be accessed in a static way
77 = The field {0}.{1} is never read locally
78 = The static field {0}.{1} should be accessed directly
79 = Unqualified access to the field {0}.{1} 
80 = The final field {0}.{1} cannot be assigned
81 = The blank final field {0} may not have been initialized
82 = The final field {0} may already have been assigned

90 = The local variable {0} is hiding another local variable defined in an enclosing type scope
91 = The local variable {0} is hiding a field from type {1}
92 = The field {0}.{1} is hiding another local variable defined in an enclosing type scope
93 = The field {0}.{1} is hiding a field from type {2}
94 = The parameter {0} is hiding another local variable defined in an enclosing type scope
95 = The parameter {0} is hiding a field from type {1}
96 = The serializable class {0} does not declare a static final serialVersionUID field of type long

100 = The method {1}({2}) is undefined for the type {0}
101 = The method {1}({2}) from the type {0} is not visible
102 = The method {1}({2}) is ambiguous for the type {0}
103 = The method {1}({2}) from the type {0} is deprecated
104 = Cannot directly invoke the abstract method {1}({2}) for the type {0}
105 = Void methods cannot return a value
106 = Cannot return a void result
107 = This method requires a body instead of a semicolon
108 = This method must return a result of type {0}

110 = This method has a constructor name
111 = Return type for the method is missing
112 = Native methods do not specify a body
113 = Abstract methods do not specify a body
114 = Cannot invoke {1}({2}) on the primitive type {0}
115 = The method {1}({2}) in the type {0} is not applicable for the arguments ({3})
116 = Cannot invoke {1}({2}) on the array type {0}
117 = The static method {1}({2}) from the type {0} should be accessed in a static way
118 = The method {1}({2}) from the type {0} is never used locally
119 = The static method {1}({2}) from the type {0} should be accessed directly 
120 = The method {1}({2}) from the type {0} refers to the missing type {3}

129 = The constructor {0}({1}) refers to the missing type {2}
130 = The constructor {0}({1}) is undefined
131 = The constructor {0}({1}) is not visible
132 = The constructor {0}({1}) is ambiguous
133 = The constructor {0}({1}) is deprecated
134 = The constructor {0}({1}) is never used locally
135 = Cannot refer to an instance field {0} while explicitly invoking a constructor
136 = Cannot refer to an instance method while explicitly invoking a constructor
137 = Recursive constructor invocation {0}({1})
138 = Cannot refer to 'this' nor 'super' while explicitly invoking a constructor
139 = Constructor call must be the first statement in a constructor
140 = Implicit super constructor {0}({1}) is undefined for default constructor. Must define an explicit constructor
141 = Implicit super constructor {0}({1}) is not visible for default constructor. Must define an explicit constructor
142 = Implicit super constructor {0}({1}) is ambiguous for default constructor. Must define an explicit constructor
143 = Implicit super constructor {0}({1}) is undefined. Must explicitly invoke another constructor
144 = Implicit super constructor {0}({1}) is not visible. Must explicitly invoke another constructor
145 = Implicit super constructor {0}({1}) is ambiguous. Must explicitly invoke another constructor
146 = Default constructor cannot handle exception type {0} thrown by implicit super constructor. Must define an explicit constructor
147 = Unhandled exception type {0} thrown by implicit super constructor

150 = The type of the expression must be an array type but it resolved to {0}
151 = Must explicitly convert the char[] to a String
152 = String constant is exceeding the limit of 65535 bytes of UTF8 encoding
153 = case expressions must be constant expressions
154 = The literal {1} of type {0} is out of range 
156 = Cannot cast from {0} to {1}
157 = Cannot instantiate the type {0}
158 = Cannot define dimension expressions when an array initializer is provided
159 = Variable must provide either dimension expressions or an array initializer
160 = The operator {0} is undefined for the argument type(s) {1}
161 = Unreachable code
162 = Cannot return from within an initializer
163 = Initializer does not complete normally
164 = Expression must return a value
165 = Unreachable catch block for {0}. Only more specific exceptions are thrown and handled by previous catch block(s).
166 = The default case is already defined
167 = Unreachable catch block for {0}. This exception is never thrown from the try statement body
168 = Unhandled exception type {0}
169 = Cannot switch on a value of type {0}. Only convertible int values or enum constants are permitted
170 = Duplicate case
171 = Duplicate label {0}
172 = break cannot be used outside of a loop or a switch
173 = continue cannot be used outside of a loop
174 = The label {0} is missing
175 = {0} is not a valid type''s argument for the synchronized statement
176 = null is not a valid argument for the synchronized statement
177 = Cannot throw null as an exception
178 = The assignment to variable {0} has no effect
179 = Possible accidental assignment in place of a comparison. A condition expression should not be reduced to an assignment
180 = Unnecessary semicolon
181 = Unnecessary cast from {0} to {1}
182 = Unnecessary cast from {0} to {1}. It is already compatible with the argument type {2}
183 = The expression of type {0} is already an instance of type {1}
184 = finally block does not complete normally
185 = The declared exception {3} is not actually thrown by the method {1}({2}) from type {0}
186 = The declared exception {2} is not actually thrown by the constructor {0}({1})
187 = Unreachable catch block for {0}. It is already handled by the catch block for {1}
188 = Empty control-flow statement
189 = Statement unnecessarily nested within else clause. The corresponding then clause does not complete normally
190 = Read access to enclosing field {0}.{1} is emulated by a synthetic accessor method. Increasing its visibility will improve your performance
191 = Write access to enclosing field {0}.{1} is emulated by a synthetic accessor method. Increasing its visibility will improve your performance
192 = Access to enclosing method {1}({2}) from the type {0} is emulated by a synthetic accessor method. Increasing its visibility will improve your performance
193 = Access to enclosing constructor {0}({1}) is emulated by a synthetic accessor method. Increasing its visibility will improve your performance
194 = Switch case may be entered by falling through previous case
195 = The method {1} is defined in an inherited type and an enclosing scope
196 = The field {0} is defined in an inherited type and an enclosing scope 
197 = The type {0} is defined in an inherited type and an enclosing scope
198 = Cannot allocate the member type {0} using its compound name when qualified by an enclosing instance. The member type name is resolved relatively to the qualifying instance type
199 = The label {0} is never explicitly referenced
200 = Cannot use {0} in a static context
201 = Cannot make a static reference to the non-static method {1}({2}) from the type {0}
202 = Cannot specify an array dimension after an empty dimension
203 = Invalid cast expression
204 = Syntax error on token "{0}", {1} expected
205 = Syntax error on token "{0}", no accurate correction available
206 = Invalid argument to operation ++/--
207 = Interfaces cannot have constructors
208 = Array constants can only be used in initializers
209 = Syntax error on keyword "{0}"; {1} expected
210 = Syntax error on keyword "{0}", no accurate correction available

220 = Unmatched bracket
221 = The primitive type {0} of {1} does not have a field {2}
222 = Invalid expression as statement
223 = The left-hand side of an assignment must be a variable
224 = Missing semicolon
225 = Invalid parenthesized expression

230 = Syntax error on token "{0}", {1} expected before this token
231 = Syntax error on token "{0}", {1} expected after this token
232 = Syntax error on token "{0}", delete this token
233 = Syntax error on tokens, delete these tokens
234 = Syntax error on tokens, they can be merge to form {0}
235 = Syntax error on token "{0}", invalid {1}
236 = Syntax error on token(s), misplaced construct(s)
237 = Syntax error on tokens, {0} expected instead
238 = Syntax error on tokens, no accurate correction available
239 = Syntax error, unexpected {0}
240 = Syntax error, insert "{0}" to complete {1}
241 = Syntax error, insert "{0}" to complete scope
242 = Syntax error, insert "{0}" to complete phrase

250 = Unexpected end of file
251 = Invalid hex literal number
252 = Invalid octal literal number
253 = Invalid character constant
254 = Invalid escape sequence (valid ones are  \\b  \\t  \\n  \\f  \\r  \\"  \\'  \\\\ )
255 = Invalid input
256 = Invalid unicode
257 = Invalid float literal number
258 = Null source string
259 = String literal is not properly closed by a double-quote
260 = Unexpected end of comment
261 = Non-externalized string literal; it should be followed by //$NON-NLS-<n>$
262 = Invalid digit (valid ones are 0..9)
263 = Invalid low surrogate: must be within 0xDC00 and 0xDFFF
264 = Invalid high surrogate: must be within 0xD800 and 0xDBFF
265 = Unnecessary $NON-NLS$ tag

280 = Discouraged access: {0}

300 = The interface {0} cannot define an initializer
301 = Duplicate modifier for the type {0}
302 = Illegal modifier for the class {0}; only public, abstract & final are permitted
303 = Illegal modifier for the interface {0}; only public & abstract are permitted
304 = Illegal modifier for the member class {0}; only public, protected, private, static, abstract & final are permitted
305 = Illegal modifier for the member interface {0}; only public, protected, private, static & abstract are permitted
306 = Illegal modifier for the local class {0}; only abstract or final is permitted
307 = Access restriction: {0}
308 = The class {0} can be either abstract or final, not both
309 = The interface member type {0} can only be public
310 = The member type {0} can only set one of public / protected / private
311 = The member type {0} cannot be declared static; static types can only be declared in static or top level types
312 = The type {0} cannot be the superclass of {1}; a superclass must be a class
313 = The type {1} cannot subclass the final class {0}
314 = Duplicate interface {0} for the type {1}
315 = The type {0} cannot be a superinterface of {1}; a superinterface must be an interface
316 = Cycle detected: the type {0} cannot extend/implement itself or one of its own member types
317 = Cycle detected: a cycle exists in the type hierarchy between {0} and {1}
318 = The nested type {0} cannot hide an enclosing type
319 = Duplicate nested type {0}
320 = No exception of type {0} can be thrown; an exception type must be a subclass of Throwable
321 = The package {0} collides with a type
322 = The type {1} collides with a package
323 = The type {1} is already defined
324 = The type {0} cannot be resolved. It is indirectly referenced from required .class files
325 = The public type {1} must be defined in its own file
326 = A package must be specified in {0} or a default package created
327 = The hierarchy of the type {0} is inconsistent
328 = The declared package "{1}" does not match the expected package "{0}"
329 = The type java.lang.Object cannot have a superclass or superinterfaces
330 = The type java.lang.Object must be a class
331 = Redundant superinterface {0} for the type {1}, already defined by {2}

###[obsolete] 330 = {0} cannot be resolved or is not a valid superclass
###[obsolete] 331 = Superclass {0} is not visible
###[obsolete] 332 = Superclass {0} is ambiguous
###[obsolete] 333 = Superclass {0} cannot be referenced using its binary name
###[obsolete] 334 = Superclass {0} is defined in an inherited type and an enclosing scope
###[obsolete] 335 = {0} cannot be resolved or is not a valid superinterface
###[obsolete] 336 = Superinterface {0} is not visible
###[obsolete] 337 = Superinterface {0} is ambiguous
###[obsolete] 338 = Superinterface {0} cannot be referenced using its binary name
###[obsolete] 339 = Superinterface {0} is defined in an inherited type and an enclosing scope

340 = Duplicate field {0}.{1}
341 = Duplicate modifier for the field {0}
342 = Illegal modifier for the field {0}; only public, protected, private, static, final, transient & volatile are permitted
343 = Illegal modifier for the interface field {0}.{1}; only public, static & final are permitted
344 = The field {0} can only set one of public / protected / private
345 = The field {0} can be either final or volatile, not both
346 = The field {0} cannot be declared static; static fields can only be declared in static or top level types

###[obsolete] 350 = {2} cannot be resolved (or is not a valid type) for the field {1}.{0}
###[obsolete] 351 = The type {2} is not visible for the field {1}.{0}
###[obsolete] 352 = The type {2} is ambiguous for the field {1}.{0}
###[obsolete] 353 = The field type {2} cannot be referenced using its binary name
###[obsolete] 354 = The field type {2} is defined in an inherited type and an enclosing scope

355 = Duplicate method {0}({2}) in type {1}
356 = Illegal modifier for parameter {0}; only final is permitted
357 = Duplicate modifier for the method {1} in type {0}
358 = Illegal modifier for the method {0}.{2}({1})
359 = Illegal modifier for the interface method {0}.{1}({2}); only public & abstract are permitted
360 = The method {1} in type {0} can only set one of public / protected / private
361 = The method {1} cannot be declared static; static methods can only be declared in a static or top level type
362 = The abstract method {1} in type {0} can only set a visibility modifier, one of public or protected
363 = The abstract method {1} in type {0} can only be defined by an abstract class
364 = void is an invalid type for the parameter {1} of the method {0}
###[obsolete] 365 = An array of void is an invalid type for the parameter {1} of the method {0}
###[obsolete] 366 = An array of void is an invalid return type for the method {0}
367 = The native method {1} cannot also be declared strictfp
368 = Duplicate modifier for parameter {0}

###[obsolete] 370 = {2} cannot be resolved (or is not a valid type) for the parameter {1} of the method {0}
###[obsolete] 371 = The type {2} is not visible for the parameter {1} of the method {0}
###[obsolete] 372 = The type {2} is ambiguous for the parameter {1} of the method {0}
###[obsolete] 373 = The parameter type {2} cannot be referenced using its binary name
###[obsolete] 374 = The parameter type {2} is defined in an inherited type and an enclosing scope
###[obsolete] 375 = {1} cannot be resolved (or is not an exception type) for the method {0}
###[obsolete] 376 = The exception type {1} is not visible for the method {0}
###[obsolete] 377 = The exception type {1} is ambiguous for the method {0}
###[obsolete] 378 = The exception type {1} cannot be referenced using its binary name
###[obsolete] 379 = The exception type {1} is defined in an inherited type and an enclosing scope
###[obsolete] 380 = {1} cannot be resolved (or is not a valid return type) for the method {0}
###[obsolete] 381 = The return type {1} is not visible for the method {0}
###[obsolete] 382 = The return type {1} is ambiguous for the method {0}
###[obsolete] 383 = The return type {1} cannot be referenced using its binary name
###[obsolete] 384 = The return type {1} is defined in an inherited type and an enclosing scope

385 = The import {0} conflicts with a type defined in the same file
386 = The import {0} collides with another import statement
387 = Only a type can be imported. {0} resolves to a package
388 = The import {0} is never used
390 = The import {0} cannot be resolved

###[obsolete] 391 = The imported type {0} is not visible
###[obsolete] 392 = The imported type {0} is ambiguous
###[obsolete] 393 = The imported type {0} cannot be referenced using its binary name
###[obsolete] 394 = The imported type {0} is defined in an inherited type and an enclosing scope

391 = The static import {0} must be a field or member type

395 = Duplicate modifier for the variable {0}
396 = Illegal modifier for the variable {0}; only final is permitted
###[obsolete] 397 = Redundant null check: The variable {0} cannot be null at this location
###[obsolete] 398 = Null pointer access: The variable {0} can only be null at this location
###[obsolete] 399 = Potential null pointer access: The variable {0} may be null at this location
	
400 = The type {3} must implement the inherited abstract method {2}.{0}({1})
401 = Cannot override the final method from {0}
402 = Exception {0} is not compatible with throws clause in {1}
403 = Exception {0} in throws clause of {1} is not compatible with {2}
404 = The return type is incompatible with {0}
405 = The inherited method {0} cannot hide the public abstract method in {1}
406 = This instance method cannot override the static method from {0}
407 = This static method cannot hide the instance method from {0}
408 = The static method {0} conflicts with the abstract method in {1}
409 = Cannot reduce the visibility of the inherited method from {0}
410 = The method {0} does not override the inherited method from {1} since it is private to a different package
411 = This class must implement the inherited abstract method {1}, but cannot override it since it is not visible from {0}. Either make the type abstract or make the inherited method visible
412 = The method {0} overrides a deprecated method from {1}
413 = The return type is incompatible with {0}, thus this interface cannot be implemented
414 = Exception {0} is not compatible with throws clause in {1}, thus this interface cannot be implemented
415 = The variable argument type {0} of the method {1} must be the last parameter
416 = The method {0} is overriding a method without making a super invocation

420 = Code snippet support cannot find the class {0}
421 = Code snippet support cannot find the method {0}.{1}({2}) 
422 = super cannot be used in the code snippet code

430 = Too many constants, the constant pool for {0} would exceed 65536 entries
431 = The type generates a string that requires more than 65535 bytes to encode in Utf8 format in the constant pool

432 = Too many fields for type {0}. Maximum is 65535
433 = Too many methods for type {0}. Maximum is 65535

440 = 'assert' should not be used as an identifier, since it is a reserved keyword from source level 1.4 on
441 = 'enum' should not be used as an identifier, since it is a reserved keyword from source level 1.5 on
442 = Enum constants cannot be surrounded by parenthesis

450 = {0} {1}

451 = Null pointer access: The variable {0} can only be null at this location
452 = Potential null pointer access: The variable {0} may be null at this location
453 = Redundant null check: The variable {0} can only be null at this location
454 = Null comparison always yields false: The variable {0} can only be null at this location
455 = Redundant assignment: The variable {0} can only be null at this location
456 = instanceof always yields false: The variable {0} can only be null at this location
457 = Redundant null check: The variable {0} cannot be null at this location
458 = Null comparison always yields false: The variable {0} cannot be null at this location

460 = Empty block should be documented

### DOC
462 = Invalid URL reference. Double quote the reference or use the href syntax
463 = Description expected after this reference
464 = Unexpected duplicated tag @{0}
465 = ''{0}'' visibility for malformed doc comments hides this ''{1}'' reference
466 = Invalid member type qualification
467 = Missing identifier
468 = Cannot make a static reference to the non-static type variable {0}
469 = Invalid param tag type parameter name
470 = Unexpected tag
471 = Missing tag for parameter {0}
472 = Missing parameter name
473 = Duplicate tag for parameter
474 = Parameter {0} is not declared
475 = Missing tag for return type
476 = Duplicate tag for return type
477 = Missing tag for declared exception {0}
478 = Missing class name
479 = Invalid class name
480 = Duplicate tag for thrown exception
481 = Exception {0} is not declared
482 = Missing reference
483 = Invalid reference
484 = Malformed link reference
485 = Invalid parameters declaration
486 = Missing comment for {0} declaration
487 = Invalid tag
488 = {0} cannot be resolved or is not a field
489 = The field {0} is not visible
490 = The field {0} is ambiguous
491 = The field {0}.{1} is deprecated
492 = The constructor {0}({1}) is undefined
493 = The constructor {0}({1}) is not visible
494 = The constructor {0}({1}) is ambiguous
495 = The constructor {0}({1}) is deprecated
496 = The method {1}({2}) is undefined for the type {0}
497 = The method {1}({2}) from the type {0} is not visible
498 = The method {1}({2}) is ambiguous for the type {0}
499 = The method {1}({2}) from the type {0} is deprecated
500 = Cannot invoke {1}({2}) on the primitive type {0}
501 = The method {1}({2}) in the type {0} is not applicable for the arguments ({3})
502 = Cannot invoke {1}({2}) on the array type {0}
503 = {0} cannot be resolved to a type
504 = The type {0} is not visible
505 = The type {0} is ambiguous
506 = The type {0} is deprecated
507 = The nested type {0} cannot be referenced using its binary name
508 = The method {1} is defined in an inherited type and an enclosing scope
509 = The field {0} is defined in an inherited type and an enclosing scope 
510 = The type {0} is defined in an inherited type and an enclosing scope
511 = {0} is an ambiguous method reference or is not a field
512 = Missing closing brace for inline tag
513 = Malformed reference (missing end space separator)
514 = Javadoc: 
515 = Missing #: "{0}"
516 = Description expected after @{0}
517 = Only static field reference is allowed for @value tag
518 = Unexpected text
519 = Invalid param tag name

### GENERICS
520 = Duplicate type parameter {0}
521 = Cannot refer to the type parameter {0} as a supertype
522 = Cannot make a static reference to the non-static type {0}
523 = The type java.lang.Object cannot be declared as a generic
524 = The type {0} is not generic; it cannot be parameterized with arguments <{1}>
525 = Incorrect number of arguments for type {0}; it cannot be parameterized with arguments <{1}>
526 = Bound mismatch: The type {0} is not a valid substitute for the bounded parameter <{2} extends {3}> of the type {1}
527 = Method {0}({2}) has the same erasure {0}({3}) as another method in type {1}
528 = Illegal forward reference to type parameter {0}
529 = The type {0} is not an interface; it cannot be specified as a bounded parameter
530 = Type safety: The constructor {0}({1}) belongs to the raw type {0}. References to generic type {2} should be parameterized
531 = Type safety: The method {0}({1}) belongs to the raw type {2}. References to generic type {3} should be parameterized
532 = Type safety: The expression of type {0} needs unchecked conversion to conform to {1}
533 = Cannot use the type parameter {0} in a catch block
534 = Cannot use the parameterized type {0} either in catch block or throws clause
535 = Cannot create a generic array of {0}
536 = Type safety: The field {1} from the raw type {2} is assigned a value of type {0}. References to generic type {3} should be parameterized
537 = The type parameter {0} should not be bounded by the final type {1}. Final types cannot be further extended
538 = Inconsistent classfile encountered: The undefined type parameter {0} is referenced from within {1}
539 = The interface {2} cannot be implemented more than once with different arguments: {0} and {1}
540 = Bound mismatch: The constructor {0}({1}) of type {2} is not applicable for the arguments ({3}). The wildcard parameter {5} has no lower bound, and may actually be more restrictive than argument {4}
541 = Bound mismatch: The method {0}({1}) of type {2} is not applicable for the arguments ({3}). The wildcard parameter {5} has no lower bound, and may actually be more restrictive than argument {4}
542 = Bound mismatch: Cannot assign expression of type {0} to wildcard type {1}. The wildcard type has no lower bound, and may actually be more restrictive than expression type
543 = Bound mismatch: The generic method {0}({1}) of type {2} is not applicable for the arguments ({3}). The inferred type {4} is not a valid substitute for the bounded parameter <{5} extends {6}>
544 = Bound mismatch: The generic constructor {0}({1}) of type {2} is not applicable for the arguments ({3}). The inferred type {4} is not a valid substitute for the bounded parameter <{5} extends {6}>
545 = Type safety: Unchecked cast from {0} to {1}
546 = Cannot perform instanceof check against parameterized type {0}. Use instead its raw form {1} since generic type information will be erased at runtime
547 = Cannot perform instanceof check against type parameter {0}. Use instead its erasure {1} since generic type information will be erased at runtime
548 = The method {0}({1}) of type {2} is not generic; it cannot be parameterized with arguments <{3}>
549 = Incorrect number of type arguments for generic method <{3}>{0}({1}) of type {2}; it cannot be parameterized with arguments <{4}>
550 = The parameterized method <{3}>{0}({1}) of type {2} is not applicable for the arguments ({4})
551 = The constructor {0}({1}) of type {2} is not generic; it cannot be parameterized with arguments <{3}>
552 = Incorrect number of type arguments for generic constructor <{3}>{0}({1}) of type {2}; it cannot be parameterized with arguments <{4}>
553 = The parameterized constructor <{3}>{0}({1}) of type {2} is not applicable for the arguments ({4})
554 = The method {0}({1}) of raw type {2} is no longer generic; it cannot be parameterized with arguments <{3}>
555 = The constructor {0}({1}) of raw type {2} is no longer generic; it cannot be parameterized with arguments <{3}>
556 = The type {1} cannot extend or implement {0}. A supertype may not specify any wildcard
557 = The generic class {0} may not subclass java.lang.Throwable
558 = Illegal class literal for the type parameter {0}
559 = Type safety: The return type {0} for {1}({2}) from the type {3} needs unchecked conversion to conform to {4} from the type {5}
560 = Name clash: The method {0}({1}) of type {2} has the same erasure as {0}({3}) of type {4} but does not override it
561 = The member type {0}<{1}> must be qualified with a parameterized type, since it is not static
562 = The member type {0} must be parameterized, since it is qualified with a parameterized type
563 = The member type {0} cannot be qualified with a parameterized type, since it is static. Remove arguments from qualifying type {1}
###[obsolete] 564 = Bound conflict: {0} is inherited with conflicting arguments
565 = Duplicate methods named {0} with the parameters ({2}) and ({3}) are defined by the type {1}
566 = Cannot allocate the member type {0} using a parameterized compound name; use its simple name and an enclosing instance of type {1}
567 = Duplicate bound {0}
568 = The array type {0} cannot be used as a type parameter bound
569 = Type safety: Unchecked invocation {0}({3}) of the generic constructor {0}({1}) of type {2}
570 = Type safety: Unchecked invocation {0}({3}) of the generic method {0}({1}) of type {2}
571 = The type parameter {0} is hiding the type {1}
572 = {0} is a raw type. References to generic type {1} should be parameterized
573 = Cannot specify any additional bound {0} when first bound is a type parameter
574 = Type safety : A generic array of {0} is created for a varargs parameter
575 = Illegal qualified access from the type parameter {0}
576 = The nested type {0} is hiding the type parameter {1} of type {2}
577 = The nested type {0} is hiding the type parameter {1} of the generic method {2}({3}) of type {4}
578 = Wildcard is not allowed at this location
579 = Unused type arguments for the non generic method {0}({1}) of type {2}; it should not be parameterized with arguments <{3}>

### FOREACH
580 = Type mismatch: cannot convert from element type {0} to {1}
581 = Can only iterate over an array or an instance of java.lang.Iterable

### SOURCE LEVEL
590 = Syntax error, type parameters are only available if source level is 1.5
591 = Syntax error, static imports are only available if source level is 1.5
592 = Syntax error, 'for each' statements are only available if source level is 1.5
593 = Syntax error, parameterized types are only available if source level is 1.5
594 = Syntax error, enum declarations are only available if source level is 1.5
595 = Syntax error, varargs are only available if source level is 1.5
596 = Syntax error, annotations are only available if source level is 1.5
597 = Syntax error, annotation declarations are only available if source level is 1.5
598 = Syntax error, annotation declaration cannot have type parameters
599 = Syntax error, enum declaration cannot have type parameters

### ANNOTATIONS
600 = Illegal modifier for the annotation attribute {0}.{1}; only public & abstract are permitted
601 = Extended dimensions are illegal in an annotation attribute declaration
602 = Package annotations must be in file package-info.java
603 = Illegal modifier for the annotation type {0}; only public & abstract are permitted
604 = Illegal modifier for the member annotation type {0}; only public, protected, private, static & abstract are permitted
605 = Invalid type {0} for the annotation attribute {2}.{1}; only primitive type, String, Class, annotation, enumeration are permitted or 1-dimensional arrays thereof
606 = Cycle detected: the annotation type {0} cannot contain attributes of the annotation type itself
607 = Cycle detected: a cycle exists between annotation attributes of {0} and {1}
608 = Duplicate annotation @{0}
609 = The annotation @{0} must define the attribute {1}
610 = Duplicate attribute {0} in annotation @{1}
611 = The attribute {0} is undefined for the annotation type {1}
612 = The value for annotation attribute {0}.{1} must be a class literal
613 = The value for annotation attribute {0}.{1} must be a constant expression
###[obsolete] 614 = The annotation field {0}.{1} must be initialized with a constant expression
615 = Illegal modifier for the annotation field {0}.{1}; only public, static & final are permitted
616 = The annotation type {0} cannot override the method {1}.{2}({3})
617 = Annotation attributes cannot have parameters
618 = Annotation attributes cannot be generic
619 = Annotation type declaration cannot have an explicit superclass
620 = Annotation type declaration cannot have explicit superinterfaces
621 = Duplicate element {0} specified in annotation @{1}
622 = The annotation @{0} is disallowed for this location
623 = The method {0}({1}) of type {2} must override a superclass method
624 = Annotation type declaration cannot have a constructor
625 = The value for annotation attribute {0}.{1} must be some @{2} annotation 
626 = The annotation type {0} should not be used as a superinterface for {1}
627 = The method {0}({1}) of type {2} should be tagged with @Override since it actually overrides a superclass method
628 = The deprecated field {0}.{1} should be annotated with @Deprecated
629 = The deprecated method {0}({1}) of type {2} should be annotated with @Deprecated
630 = The deprecated type {0} should be annotated with @Deprecated
631 = Unsupported @SuppressWarnings("{0}")
632 = The value for annotation attribute {0}.{1} must be an array initializer
633 = The value for annotation attribute {0}.{1} must be an enum constant expression
634 = The method {0}({1}) of type {2} must override or implement a supertype method
635 = Unnecessary @SuppressWarnings("{0}")

### MORE GENERICS
660 = Unused type arguments for the non generic constructor {0}({1}) of type {2}; it should not be parameterized with arguments <{3}>

### CORRUPTED BINARIES
700 = The class file {0} contains a signature ''{1}'' ill-formed at position {2}

### CORRUPTED SOURCES
701 = Cannot read the source from {0}; either the file uses a different encoding than {1} or it is corrupted
702 = Cannot read the source from {0} due to internal exception {1}

### AUTOBOXING
720 = The expression of type {0} is boxed into {1}
721 = The expression of type {0} is unboxed into {1}

### ENUMS
750 = Illegal modifier for the enum {0}; only public is permitted
751 = Illegal modifier for the enum constant {0}; no modifier is allowed
752 = Illegal modifier for the local enum {0}; only abstract is permitted
753 = Illegal modifier for the member enum {0}; only public, protected, private & static are permitted
754 = The enum {1} already defines the method {0}({2}) implicitly
755 = The enum constant {0}.{1} reference cannot be qualified in a case label
756 = The type {1} may not subclass {0} explicitly
757 = Cannot invoke super constructor from enum constructor {0}({1})
758 = The enum {2} can only define the abstract method {0}({1}) if it also defines enum constants with corresponding implementations
759 = The field {0}.{1} cannot be referenced from an enum case label; only enum constants can be used in enum switch
760 = Illegal modifier for the enum constructor; only private is permitted.
761 = The enum constant {0}.{1} has no corresponding case label
762 = Cannot refer to the static enum field {0}.{1} within an initializer
763 = The enum constant {2} must define the abstract method {0}({1})

### VARARGS
800 = Extended dimensions are illegal for a variable argument
801 = The argument of type {0} should explicitly be cast to {1} for the invocation of the varargs method {2}({3}) from type {4}. It could alternatively be cast to {5} for a varargs invocation
802 = The argument of type {0} should explicitly be cast to {1} for the invocation of the varargs constructor {2}({3}). It could alternatively be cast to {4} for a varargs invocation
803 = Varargs methods should only override or be overridden by other varargs methods unlike {2}.{0}({1}) and {4}.{0}({3})

### GENERIC JAVADOC
850 = Bound mismatch: The generic method {0}({1}) of type {2} is not applicable for the arguments ({3}). The inferred type {4} is not a valid substitute for the bounded parameter <{5} extends {6}>
851 = The method {0}({1}) of type {2} is not generic; it cannot be parameterized with arguments <{3}>
852 = Incorrect number of type arguments for generic method <{3}>{0}({1}) of type {2}; it cannot be parameterized with arguments <{4}>
853 = The parameterized method <{3}>{0}({1}) of type {2} is not applicable for the arguments ({4})
854 = The method {0}({1}) of raw type {2} is no longer generic; it cannot be parameterized with arguments <{3}>
855 = Bound mismatch: The generic constructor {0}({1}) of type {2} is not applicable for the arguments ({3}). The inferred type {4} is not a valid substitute for the bounded parameter <{5} extends {6}>
856 = The constructor {0}({1}) of type {2} is not generic; it cannot be parameterized with arguments <{3}>
857 = Incorrect number of type arguments for generic constructor <{3}>{0}({1}) of type {2}; it cannot be parameterized with arguments <{4}>
858 = The parameterized constructor <{3}>{0}({1}) of type {2} is not applicable for the arguments ({4})
859 = The constructor {0}({1}) of raw type {2} is no longer generic; it cannot be parameterized with arguments <{3}>

### ELABORATIONS
## Access restrictions
78592 = The type {1} is not accessible due to restriction on classpath entry {0}
78593 = The type {1} is not accessible due to restriction on required project {0}
78594 = The type {1} is not accessible due to restriction on required library {0}
78596 = The field {1} from the type {2} is not accessible due to restriction on classpath entry {0}
78597 = The field {1} from the type {2} is not accessible due to restriction on required project {0}
78598 = The field {1} from the type {2} is not accessible due to restriction on required library {0}
78600 = The constructor {1} is not accessible due to restriction on classpath entry {0}
78601 = The constructor {1} is not accessible due to restriction on required project {0}
78602 = The constructor {1} is not accessible due to restriction on required library {0}
78604 = The method {1} from the type {2} is not accessible due to restriction on classpath entry {0}
78606 = The method {1} from the type {2} is not accessible due to restriction on required library {0}
78605 = The method {1} from the type {2} is not accessible due to restriction on required project {0}
