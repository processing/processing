<?xml version="1.0" encoding="UTF-8"?>
<office:document-content xmlns:office="urn:oasis:names:tc:opendocument:xmlns:office:1.0" xmlns:style="urn:oasis:names:tc:opendocument:xmlns:style:1.0" xmlns:text="urn:oasis:names:tc:opendocument:xmlns:text:1.0" xmlns:table="urn:oasis:names:tc:opendocument:xmlns:table:1.0" xmlns:draw="urn:oasis:names:tc:opendocument:xmlns:drawing:1.0" xmlns:fo="urn:oasis:names:tc:opendocument:xmlns:xsl-fo-compatible:1.0" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:meta="urn:oasis:names:tc:opendocument:xmlns:meta:1.0" xmlns:number="urn:oasis:names:tc:opendocument:xmlns:datastyle:1.0" xmlns:svg="urn:oasis:names:tc:opendocument:xmlns:svg-compatible:1.0" xmlns:chart="urn:oasis:names:tc:opendocument:xmlns:chart:1.0" xmlns:dr3d="urn:oasis:names:tc:opendocument:xmlns:dr3d:1.0" xmlns:math="http://www.w3.org/1998/Math/MathML" xmlns:form="urn:oasis:names:tc:opendocument:xmlns:form:1.0" xmlns:script="urn:oasis:names:tc:opendocument:xmlns:script:1.0" xmlns:ooo="http://openoffice.org/2004/office" xmlns:ooow="http://openoffice.org/2004/writer" xmlns:oooc="http://openoffice.org/2004/calc" xmlns:dom="http://www.w3.org/2001/xml-events" xmlns:xforms="http://www.w3.org/2002/xforms" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" office:version="1.0"><office:scripts><office:event-listeners><script:event-listener script:language="ooo:StarBasic" script:event-name="office:start-app" script:macro-name="document:ORA.Helpers.StartSmartStyler"/></office:event-listeners></office:scripts><office:font-face-decls><style:font-face style:name="StarSymbol" svg:font-family="StarSymbol" style:font-charset="x-symbol"/><style:font-face style:name="Symbol" svg:font-family="Symbol" style:font-family-generic="decorative" style:font-pitch="variable" style:font-charset="x-symbol"/><style:font-face style:name="Courier1" svg:font-family="Courier"/><style:font-face style:name="Tahoma1" svg:font-family="Tahoma, Lucidasans, &apos;Lucida Sans&apos;, &apos;Arial Unicode MS&apos;"/><style:font-face style:name="Courier-Bold" svg:font-family="Courier-Bold, Courier" style:font-family-generic="modern"/><style:font-face style:name="Courier2" svg:font-family="Courier" style:font-adornments="Bold" style:font-family-generic="modern" style:font-pitch="fixed"/><style:font-face style:name="Courier" svg:font-family="Courier" style:font-adornments="Regular" style:font-family-generic="modern" style:font-pitch="fixed"/><style:font-face style:name="Bitstream Vera Sans2" svg:font-family="&apos;Bitstream Vera Sans&apos;" style:font-pitch="variable"/><style:font-face style:name="Bitstream Vera Sans1" svg:font-family="&apos;Bitstream Vera Sans&apos;" style:font-adornments="Italic" style:font-pitch="variable"/><style:font-face style:name="Bitstream Vera Serif2" svg:font-family="&apos;Bitstream Vera Serif&apos;" style:font-adornments="Bold" style:font-pitch="variable"/><style:font-face style:name="Bitstream Vera Serif1" svg:font-family="&apos;Bitstream Vera Serif&apos;" style:font-adornments="Regular" style:font-pitch="variable"/><style:font-face style:name="HG Mincho Light J" svg:font-family="&apos;HG Mincho Light J&apos;, &apos;MS Mincho&apos;, &apos;HG Mincho J&apos;, &apos;HG Mincho L&apos;, &apos;HG Mincho&apos;, Mincho, &apos;MS PMincho&apos;, &apos;HG Mincho Light J&apos;, &apos;MS Gothic&apos;, &apos;HG Gothic J&apos;, &apos;HG Gothic B&apos;, &apos;HG Gothic&apos;, Gothic, &apos;MS PGothic&apos;, &apos;Andale Sans UI&apos;, &apos;Arial Unicode MS&apos;, &apos;Lucida Sans Unicode&apos;, Tahoma" style:font-pitch="variable"/><style:font-face style:name="Tahoma" svg:font-family="Tahoma, Lucidasans, &apos;Lucida Sans&apos;, &apos;Arial Unicode MS&apos;" style:font-pitch="variable"/><style:font-face style:name="Times" svg:font-family="Times" style:font-pitch="variable"/><style:font-face style:name="Bitstream Vera Serif" svg:font-family="&apos;Bitstream Vera Serif&apos;" style:font-family-generic="roman" style:font-pitch="variable"/><style:font-face style:name="Times New Roman" svg:font-family="&apos;Times New Roman&apos;" style:font-family-generic="roman" style:font-pitch="variable"/><style:font-face style:name="Bitstream Vera Sans" svg:font-family="&apos;Bitstream Vera Sans&apos;" style:font-family-generic="swiss" style:font-pitch="variable"/><style:font-face style:name="Helvetica" svg:font-family="Helvetica" style:font-family-generic="swiss" style:font-pitch="variable"/></office:font-face-decls><office:automatic-styles><style:style style:name="P1" style:family="paragraph" style:parent-style-name="ChapterLabel"><style:paragraph-properties fo:text-align="justify" style:justify-single-word="false"/></style:style><style:style style:name="P2" style:family="paragraph" style:parent-style-name="ChapterTitle"><style:paragraph-properties fo:text-align="justify" style:justify-single-word="false"/></style:style><style:style style:name="P3" style:family="paragraph" style:parent-style-name="CodeEmphasis"><style:text-properties fo:color="#545454" style:font-name="Courier-Bold" fo:font-size="11pt" fo:language="en" fo:country="US" fo:font-weight="bold" style:font-name-asian="Courier-Bold" style:font-size-asian="11pt" style:language-asian="en" style:country-asian="US" style:font-weight-asian="bold" style:font-name-complex="Courier-Bold" style:font-size-complex="11pt" style:font-weight-complex="bold"/></style:style><style:style style:name="T1" style:family="text"><style:text-properties style:font-name="Bitstream Vera Serif1" fo:font-size="10pt" fo:font-weight="normal"/></style:style><style:style style:name="T2" style:family="text" style:parent-style-name="Emphasis"><style:text-properties fo:font-style="normal" style:font-style-asian="normal" style:font-style-complex="normal"/></style:style><style:style style:name="fr1" style:family="graphic" style:parent-style-name="Graphics"><style:graphic-properties style:horizontal-pos="center" style:horizontal-rel="paragraph" style:mirror="none" fo:clip="rect(0in 0in 0in 0in)" draw:luminance="0%" draw:contrast="0%" draw:red="0%" draw:green="0%" draw:blue="0%" draw:gamma="100%" draw:color-inversion="false" draw:image-opacity="100%" draw:color-mode="standard"/></style:style><style:style style:name="fr2" style:family="graphic" style:parent-style-name="Graphics"><style:graphic-properties style:vertical-pos="from-top" style:vertical-rel="paragraph" style:horizontal-pos="from-left" style:horizontal-rel="paragraph" style:mirror="none" fo:clip="rect(0in 0in 0in 0in)" draw:luminance="0%" draw:contrast="0%" draw:red="0%" draw:green="0%" draw:blue="0%" draw:gamma="100%" draw:color-inversion="false" draw:image-opacity="100%" draw:color-mode="standard"/></style:style></office:automatic-styles>
<office:body>
<office:text>
<text:p text:style-name="P1">4</text:p>
<text:p text:style-name="P2">5 Connections and Correlations</text:p>
<text:p text:style-name="Heading_20_1">What is the question?</text:p>
<text:p text:style-name="Body_20_Text">
In 2004, the Boston Red Sox won the World Series after an 86 year hiatus. As a Red Sox fan, I found this somewhat bittersweet in the sense that the second highest paid team in baseball finally managed to win a championship. With a total salary of around $133 million dollars, they weren't exactly young upstarts. This made me curious about how that works across the league, with raw salaries and the general performance of the individual teams. 
</text:p>
<text:p text:style-name="Body_20_Text">
George Steinbrenner, the owner of the New York Yankees, for instance, had in recent years been accused of trying to "buy" the World Series trophy by assembling a collection of highly paid all-stars. On the other hand, the performance of the Oakland A's, on the other hand, had in years prior far exceeded their overall salary. This story was told by Michael Lewis in the book <text:span text:style-name="Technical_20_Italic">Moneyball</text:span>, which covered how Billy Beane, the General Manager (GM) of the A's made use of statistics to pursue players who had promising numbers but were below the radar because they weren't always standouts in the traditional sense. 
</text:p>
<text:p text:style-name="Body_20_Text">
Bill James was one of the first to bring statistics-oriented thinking to Baseball with his writing and later when he began publishing <text:span text:style-name="Technical_20_Italic">The Bill James Baseball Abstract</text:span> in 1977. Similar ideas led to the founding of the Society for American Baseball Research (SABR), from which the term <text:span text:style-name="Technical_20_Italic">Sabermetrics</text:span> was coined, to refer to this numbers-driven approach to the game. The extent to which statistics can be used remains a controversial topic in sports, a battle between a perception of watering the game down to mere mathematics, versus a focus on the intangible aspects of talented people playing team sports.
</text:p>
<text:p text:style-name="Body_20_Text">
As with any narrative, <text:span text:style-name="Technical_20_Italic">Moneyball</text:span> presents an over-simplification of the system, as does relating total salary in a given year to performance-to-date. There are more complex factors including how contracts work over multiple years, the health of a team's farm system, and scoring methods for individual players that could be taken into consideration. The original version of this project was thrown together while watching a game on television and it's perhaps dangerously un-advanced, given the amount of time and energy that's put into the analysis of sports statistics. 
</text:p>
<text:p text:style-name="Body_20_Text">
However, a win is a win, and as a gross measure, showing the simple correlation can be quite revealing, in particular to observe shifts over the course of a season. Non-baseball fans also seem to enjoy it because wins and losses are straightforward, and they're probably also aware of ever-growing salaries paid to professional atheletes.
</text:p>
<text:p text:style-name="Heading_20_1">Approach</text:p>
<text:p text:style-name="Body_20_Text">
(this needs more work, but will cover a bit about what we're about to do)
</text:p>
<text:p text:style-name="Body_20_Text">
up/down characteristics, will get into in the representation...
</text:p>
<text:p text:style-name="Body_20_Text">
in this chapter we'll cover
</text:p>
<text:p text:style-name="Body_20_Text">
correlations and parallel coordinates
</text:p>
<text:p text:style-name="Body_20_Text">
parsing online data set, detective work to figure out how it goes
</text:p>
<text:p text:style-name="Body_20_Text">
dynamically pulling data for multiple days (things start to move)
</text:p>
<text:p text:style-name="Body_20_Text">
label placement (refinement)
</text:p>
<text:p text:style-name="Heading_20_1">Preprocessing: Acquiring Win/Loss Data</text:p>
<text:p text:style-name="Body_20_Text">
To find win/loss records for each team, we turn to MLB.com, the web site of Major League Baseball. The standings page is a suitable place to get the information:
</text:p>
<text:p text:style-name="Text_20_body_20_indent">
<text:span text:style-name="Hyperlink">
http://mlb.mlb.com/mlb/standings/index.jsp
</text:span>
</text:p>
<text:p text:style-name="Body_20_Text">
Figure 01 The MLB.com standings page for 2007
</text:p>
<text:p text:style-name="Body_20_Text">
Pulling the standings information from this page requires a little bit of detective work. The general process to follow when dealing with web pages:
</text:p>
<text:p text:style-name="Body_20_Text">
Navigate to the page that contains the data. Because there will be lots of header and footer material, make a note of identifying factors where the data starts. In this case, the table starts near the text "American League," and specifically, beneath "East" for the table heading. 
</text:p>
<text:p text:style-name="Body_20_Text">
Choose View Source and take a look at the code. Use Find to look for your identifiers (American League or East) to see where the data begins. It's important to choose good identifiers. It might be tempting to use "Boston," the first data element in the table. However, in this case that will not work, because the "Select favorite team" pop-up menu already contains a "Boston" entry that will throw off your search.
</text:p>
<text:p text:style-name="Body_20_Text">
In most cases, the data will begin nearby the identifier you've chosen. The identifying portions will be part of an HTML <text:span text:style-name="Literal">&lt;TABLE&gt;</text:span> tag, with the data stored inside a <text:span text:style-name="Literal">&lt;TD&gt;</text:span> and <text:span text:style-name="Literal">&lt;/TD&gt;</text:span> pair.
</text:p>
<text:p text:style-name="Body_20_Text">
To make things trickier, in this example, the relevant HTML is actually built using JavaScript. The location near "American League," where we might normally find the data, instead contain lines that use a pair of functions named <text:span text:style-name="Literal">buildTitleRows()</text:span> and <text:span text:style-name="Literal">buildRows()</text:span>:
</text:p>
<text:p text:style-name="Code">
<text:s text:c="8" />
&lt;div style="padding-top:15px;"&gt;
</text:p>
<text:p text:style-name="Code">
<text:s text:c="12" />
&lt;h1&gt;American League&lt;/h1&gt;
</text:p>
<text:p text:style-name="Code">
<text:s text:c="12" />
&lt;img src="/mlb/images/al_symbol.gif" width="38" height="31" alt="
</text:p>
<text:p text:style-name="Code">
<text:s text:c="8" />
&lt;/div&gt;
</text:p>
<text:p text:style-name="Code">
<text:s text:c="4" />
&lt;/td&gt;
</text:p>
<text:p text:style-name="Code">
&lt;/tr&gt;
</text:p>
<text:p text:style-name="Code">
<text:s text:c="4" />

</text:p>
<text:p text:style-name="Code">
&lt;script&gt;dataExists();&lt;/script&gt;
</text:p>
<text:p text:style-name="Code">

</text:p>
<text:p text:style-name="Code">
&lt;script&gt;
</text:p>
<text:p text:style-name="Code">
&lt;tbody id="ale"&gt;&lt;script&gt;
</text:p>
<text:p text:style-name="Code">
<text:s text:c="4" />

</text:p>
<text:p text:style-name="Code">
&lt;script&gt;
</text:p>
<text:p text:style-name="Code">
&lt;tbody id="alc"&gt;&lt;script&gt;
</text:p>
<text:p text:style-name="Code">
<text:s text:c="4" />

</text:p>
<text:p text:style-name="Code">
&lt;script&gt;
</text:p>
<text:p text:style-name="Code">
&lt;tbody id="alw"&gt;&lt;script&gt;
</text:p>
<text:p text:style-name="Code">
<text:s text:c="4" />

</text:p>
<text:p text:style-name="Code">
&lt;tr&gt;
</text:p>
<text:p text:style-name="Code">
<text:s text:c="4" />
&lt;td colspan="16" style="padding-top:15px;"&gt;
</text:p>
<text:p text:style-name="Code">
<text:s text:c="8" />
&lt;h1&gt;
</text:p>
<text:p text:style-name="Code">
<text:s text:c="8" />
&lt;img src="/mlb/images/nl_symbol.gif" width="38" height="31" t="National League" border="0" align="absmiddle" /&gt;
</text:p>
<text:p text:style-name="Code">
<text:s text:c="4" />
&lt;/td&gt;
</text:p>
<text:p text:style-name="Code">
&lt;/tr&gt;
</text:p>
<text:p text:style-name="Code">
<text:s text:c="1" />

</text:p>
<text:p text:style-name="Code">
&lt;script&gt;
</text:p>
<text:p text:style-name="Code">
&lt;tbody id="nle"&gt;&lt;script&gt;
</text:p>
<text:p text:style-name="Code">

</text:p>
<text:p text:style-name="Code">
&lt;script&gt;
</text:p>
<text:p text:style-name="Code">
&lt;tbody id="nlc"&gt;&lt;script&gt;
</text:p>
<text:p text:style-name="Code">
<text:s text:c="1" />

</text:p>
<text:p text:style-name="Code">
&lt;script&gt;
</text:p>
<text:p text:style-name="Code">
&lt;tbody id="nlw"&gt;&lt;script&gt;
</text:p>
<text:p text:style-name="Body_20_Text">
An educated guess will tell you that <text:span text:style-name="Literal">ale</text:span> is an abbreviation for the American League East division, <text:span text:style-name="Literal">alc</text:span> stands for American League Central, and so on. (A less educated guess could ascertain the same by noting that this is the American League (AL) table, with subheadings East, Central, and West, abbreviated E, C, and W).
</text:p>
<text:p text:style-name="Body_20_Text">
Next thing to figure out is where the <text:span text:style-name="Literal">standings_rs_ale</text:span> array is created, along with five others like it. Another use of the Find command reveals lines that load each array from individual <text:span text:style-name="Filename">.js</text:span> (JavaScript) files:
</text:p>
<text:p text:style-name="Code">
&lt;script src="/components/game/year_2007/month_04/day_15/
</text:p>
<text:p text:style-name="Code">
&lt;script src="/components/game/year_2007/month_04/day_15/
</text:p>
<text:p text:style-name="Code">
&lt;script src="/components/game/year_2007/month_04/day_15/
</text:p>
<text:p text:style-name="Code">
&lt;script src="/components/game/year_2007/month_04/day_15/
</text:p>
<text:p text:style-name="Code">
&lt;script src="/components/game/year_2007/month_04/day_15/
</text:p>
<text:p text:style-name="Code">
&lt;script src="/components/game/year_2007/month_04/day_15/
</text:p>
<text:p text:style-name="Body_20_Text">
The URL for the first item reads:
</text:p>
<text:p text:style-name="Code">
/components/game/year_2007/month_04/day_15/standings_rs_ale.js
</text:p>
<text:p text:style-name="Body_20_Text">
Because a forward slash is found at the beginning, the reference points to the root of the site, meaning that the full URL is:
</text:p>
<text:p text:style-name="Text_20_body_20_indent">
<text:span text:style-name="Hyperlink">
http://mlb.mlb.com
</text:span>
</text:p>
<text:p text:style-name="Body_20_Text">
Note: If the text did not begin with a slash, the URL would instead be <text:span text:style-name="Technical_20_Italic">relative</text:span>, to the original page (<text:span text:style-name="Literal">http://mlb.mlb.com/mlb/standings/index.jsp</text:span>) which would make the new URL {{http://mlb.mlb.com/mlb/standings/
</text:p>
<text:p text:style-name="Body_20_Text">
For the six divisions, the URLs are then:
</text:p>
<text:p text:style-name="Code">
// American League (AL)
</text:p>
<text:p text:style-name="Text_20_body_20_indent">
<text:span text:style-name="Hyperlink">
http://mlb.mlb.com/components/game/year_2007/month_04/day_15/standings_rs_ale.js
</text:span>
</text:p>
<text:p text:style-name="Text_20_body_20_indent">
<text:span text:style-name="Hyperlink">
http://mlb.mlb.com/components/game/year_2007/month_04/day_15/standings_rs_alc.js
</text:span>
</text:p>
<text:p text:style-name="Text_20_body_20_indent">
<text:span text:style-name="Hyperlink">
http://mlb.mlb.com/components/game/year_2007/month_04/day_15/standings_rs_alw.js
</text:span>
</text:p>
<text:p text:style-name="Code">

</text:p>
<text:p text:style-name="Code">
// National League (NL)
</text:p>
<text:p text:style-name="Text_20_body_20_indent">
<text:span text:style-name="Hyperlink">
http://mlb.mlb.com/components/game/year_2007/month_04/day_15/standings_rs_nle.js
</text:span>
</text:p>
<text:p text:style-name="Text_20_body_20_indent">
<text:span text:style-name="Hyperlink">
http://mlb.mlb.com/components/game/year_2007/month_04/day_15/standings_rs_nlc.js
</text:span>
</text:p>
<text:p text:style-name="Text_20_body_20_indent">
<text:span text:style-name="Hyperlink">
http://mlb.mlb.com/components/game/year_2007/month_04/day_15/standings_rs_nlw.js
</text:span>
</text:p>
<text:p text:style-name="Heading_20_1">Preprocessing: Parsing the Win/Loss files (Parse &amp; Filter)</text:p>
<text:p text:style-name="Body_20_Text">
Entering the first URL for <text:span text:style-name="Literal">standings_rs_ale.js</text:span> into a browser will display the JavaScript source file that creates the <text:span text:style-name="Literal">standings_rs_ale</text:span> array:
</text:p>
<text:p text:style-name="Code">
var standings_rs_ale = [{
</text:p>
<text:p text:style-name="Code">
<text:s text:c="1" />
w: '6',
</text:p>
<text:p text:style-name="Code">
<text:s text:c="1" />
elim: '-',
</text:p>
<text:p text:style-name="Code">
<text:s text:c="1" />
rs: '51',
</text:p>
<text:p text:style-name="Code">
<text:s text:c="1" />
div: 'ale',
</text:p>
<text:p text:style-name="Code">
<text:s text:c="1" />
gameid: '2007_04_16_anamlb_bosmlb_1',
</text:p>
<text:p text:style-name="Code">
<text:s text:c="1" />
status: 'F',
</text:p>
<text:p text:style-name="Code">
<text:s text:c="1" />
pre: null,
</text:p>
<text:p text:style-name="Code">
<text:s text:c="1" />
last10: '6-4',
</text:p>
<text:p text:style-name="Code">
<text:s text:c="1" />
onerun: '1-0',
</text:p>
<text:p text:style-name="Code">
<text:s text:c="1" />
xtr: '0-0',
</text:p>
<text:p text:style-name="Code">
<text:s text:c="1" />
nextg: '4/16 v LAA, W 7-2',
</text:p>
<text:p text:style-name="Code">
<text:s text:c="1" />
vsW: '4-3',
</text:p>
<text:p text:style-name="Code">
<text:s text:c="1" />
ra: '28',
</text:p>
<text:p text:style-name="Code">
<text:s text:c="1" />
gb: '-',
</text:p>
<text:p text:style-name="Code">
<text:s text:c="1" />
wrap: '/NASApp/mlb/news/wrap.jsp?ymd=20070414&content_id=1898390&vkey=wrapup2005&fext=.jsp&c_id=mlb',
</text:p>
<text:p text:style-name="Code">
<text:s text:c="1" />
home: '3-1',
</text:p>
<text:p text:style-name="Code">
<text:s text:c="1" />
code: 'bos',
</text:p>
<text:p text:style-name="Code">
<text:s text:c="1" />
pct: '.600',
</text:p>
<text:p text:style-name="Code">
<text:s text:c="1" />
league_sensitive_team_name: 'Boston',
</text:p>
<text:p text:style-name="Code">
<text:s text:c="1" />
vsC: '2-1',
</text:p>
<text:p text:style-name="Code">
<text:s text:c="1" />
vsE: '0-0',
</text:p>
<text:p text:style-name="Code">
<text:s text:c="1" />
vsR: '5-4',
</text:p>
<text:p text:style-name="Code">
<text:s text:c="1" />
vsL: '1-0',
</text:p>
<text:p text:style-name="Code">
<text:s text:c="1" />
xwl: '7-3',
</text:p>
<text:p text:style-name="Code">
<text:s text:c="1" />
strk: 'W2',
</text:p>
<text:p text:style-name="Code">
<text:s text:c="1" />
l: '4',
</text:p>
<text:p text:style-name="Code">
<text:s text:c="1" />
lastg: '4/14 v LAA, W 8-0',
</text:p>
<text:p text:style-name="Code">
<text:s text:c="1" />
interleague: '0-0',
</text:p>
<text:p text:style-name="Code">
<text:s text:c="1" />
team: 'Boston',
</text:p>
<text:p text:style-name="Code">
<text:s text:c="1" />
road: '3-3'
</text:p>
<text:p text:style-name="Code">
}, {
</text:p>
<text:p text:style-name="Body_20_Text">
Web developers might recognize this as JavaScript Object Notation (JSON) syntax. We won't get into the specifics of JSON here, see the Parse chapter for more information about how it works.
</text:p>
<text:p text:style-name="Body_20_Text">
This is the content for the first team, and four additional blocks like this one follow. Only a few pieces of information are needed from this file. Most useful will be the two or three digit code used to identify the team (because this will later be used to index other kinds of data) from the line that reads:
</text:p>
<text:p text:style-name="Code">
code: 'bos',
</text:p>
<text:p text:style-name="Body_20_Text">
Next the line for wins:
</text:p>
<text:p text:style-name="Code">
w: '6',
</text:p>
<text:p text:style-name="Body_20_Text">
and for losses:
</text:p>
<text:p text:style-name="Code">
l: '4',
</text:p>
<text:p text:style-name="Body_20_Text">
We will also want a team name to show in the interface, and luckily there is a variable named <text:span text:style-name="Literal">team</text:span> that looks like it might do the trick. However, it lists <text:span text:style-name="Literal">New York</text:span> as the value for the New York Yankees, which won't be useful when trying to differentiate the Yankees from the Mets, who also hail from New York. Instead, the <text:span text:style-name="Literal">league_sensitive_team_name</text:span> value will be more useful. For instance, the entry for the Mets reads:
</text:p>
<text:p text:style-name="Code">
league_sensitive_team_name: 'NY Mets',
</text:p>
<text:p text:style-name="Body_20_Text">
Lines between two teams' data begin with a <text:span text:style-name="Literal">{</text:span> character, so each time that character is found, the new information can be added to the list for that team. Grabbing the data for all of the teams is simply a matter of parsing this information properly. The following code reads one of the files, and parses the data into 
</text:p>
<text:p text:style-name="Body_20_Text">
Note: It would also be possible to use a proper JSON parser to read the data, but because the data shown here is so simple, using the parser would be overkill, making the program run more slowly, and increasing its download size.
</text:p>
<text:p text:style-name="Body_20_Text">
Introducing Regular Expressions
</text:p>
<text:p text:style-name="Body_20_Text">
The following function will read from one of these <text:span text:style-name="Literal">.js</text:span> files and print each team code that it finds, followed by the win-loss record for that team. The code introduces <text:span text:style-name="Technical_20_Italic">regular expressions</text:span>, which are extremely useful when parsing data.
</text:p>
<text:p text:style-name="Code">
void parseWinLoss(String[] lines) {
</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
Pattern p = Pattern.compile("\\s+([\\w\\d]+):\\s'(.*)',?");
</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />

</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
String teamCode = "";
</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
int wins = 0;
</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
int losses = 0;
</text:p>
<text:p text:style-name="Code">

</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
for (int i = 0; i &lt; lines.length; i++) {
</text:p>
<text:p text:style-name="Code">
<text:s text:c="4" />
Matcher m = p.matcher(lines[i]);
</text:p>
<text:p text:style-name="Code">

</text:p>
<text:p text:style-name="Code">
<text:s text:c="4" />
if (m.matches()) {
</text:p>
<text:p text:style-name="Code">
<text:s text:c="6" />
String attr = m.group(1);
</text:p>
<text:p text:style-name="Code">
<text:s text:c="6" />
String value = m.group(2);
</text:p>
<text:p text:style-name="Code">

</text:p>
<text:p text:style-name="Code">
<text:s text:c="6" />
if (attr.equals("code")) {
</text:p>
<text:p text:style-name="Code">
<text:s text:c="8" />
teamCode = value;
</text:p>
<text:p text:style-name="Code">
<text:s text:c="6" />
} else if (attr.equals("w")) {
</text:p>
<text:p text:style-name="Code">
<text:s text:c="8" />
wins = int(value);
</text:p>
<text:p text:style-name="Code">
<text:s text:c="6" />
} else if (attr.equals("l")) {
</text:p>
<text:p text:style-name="Code">
<text:s text:c="8" />
losses = int(value);
</text:p>
<text:p text:style-name="Code">
<text:s text:c="6" />
}
</text:p>
<text:p text:style-name="Code">

</text:p>
<text:p text:style-name="Code">
<text:s text:c="4" />
} else {
</text:p>
<text:p text:style-name="Code">
<text:s text:c="6" />
if (lines[i].startsWith("}")) {
</text:p>
<text:p text:style-name="Code">
<text:s text:c="8" />
// This is the end of a group, print the values
</text:p>
<text:p text:style-name="Code">
<text:s text:c="8" />
println(teamCode + " " + wins + "-" + losses);
</text:p>
<text:p text:style-name="Code">
<text:s text:c="6" />
}
</text:p>
<text:p text:style-name="Code">
<text:s text:c="4" />
}
</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
}
</text:p>
<text:p text:style-name="Code">
}
</text:p>
<text:p text:style-name="Body_20_Text">
Looking at the original data, the basic format of a line is as follows:
</text:p>
<text:p text:style-name="Code">
[space] [attribute name] : [space] ' [value] ' ,
</text:p>
<text:p text:style-name="Body_20_Text">
This sort of template is common when parsing data, and can be handled with a regular expression (or <text:span text:style-name="Technical_20_Italic">regexp</text:span>). A regexp is defined by a pattern, such as the one above, and a matcher, which checks the pattern against some input data. A pattern is made up of a series of symbols that identify white space, characters, numbers and how many of each are expected. The symbols are initially a confusing mess, but after some time they will become familiar (they'll be less confusing, even if they still look like a mess). The pattern <text:span text:style-name="Literal">\\s+([\\w\\d]+):\\s'(.*)',?</text:span> used above identifies the following:
</text:p>
<text:p text:style-name="Body_20_Text">
<text:span text:style-name="Literal">\\s+</text:span> – This part matches the beginning of the line. The \s pattern means "any whitespace." Because \ is used to identify special characters in a <text:span text:style-name="Literal">String</text:span> (i.e. <text:span text:style-name="Literal">\t</text:span> for TAB or <text:span text:style-name="Literal">\n</text:span> for newline), an actual slash is specified by a double slash: <text:span text:style-name="Literal">\\</text:span>. The <text:span text:style-name="Literal">+</text:span> symbol at the end means to look for one or more characters.
</text:p>
<text:p text:style-name="Body_20_Text">
<text:span text:style-name="Literal">([\\w\\d])</text:span> – This portion matches the name of the variable (such as <text:span text:style-name="Literal">w</text:span> or <text:span text:style-name="Literal">team</text:span>). The \w pattern specifies any word character (i.e. letters). The \d pattern specifies digits (0-9). Brackets enclose a set of possible characters, so in this case <text:span text:style-name="Literal">[\\w\\d]</text:span> means "any word or digit character." The <text:span text:style-name="Literal">+</text:span> at the end specifies "one or more." The entire grouping inside parentheses means to mark that set of characters as a <text:span text:style-name="Technical_20_Italic">group</text:span>. This means that the matching characters can later be extracted.
</text:p>
<text:p text:style-name="Body_20_Text">
<text:span text:style-name="Literal">:</text:span> – This is literally just the colon character, found after the variable name.
</text:p>
<text:p text:style-name="Body_20_Text">
<text:span text:style-name="Literal">\\s</text:span> – Match a single whitespace character, the space after the colon.
</text:p>
<text:p text:style-name="Body_20_Text">
<text:span text:style-name="Literal">'</text:span> – Matches the single quote at the beginning of the variable's value.
</text:p>
<text:p text:style-name="Body_20_Text">
<text:span text:style-name="Literal">(.*)</text:span> – This part matches the value found inside the single quotes. The <text:span text:style-name="Literal">.</text:span> operator matches "anything." Any character is possible. The <text:span text:style-name="Literal">*</text:span> pattern specifies zero or more of the operator that precedes it (similar to how the <text:span text:style-name="Literal">+</text:span> operator matches one or more). The parentheses mark this as the second grouping to be retrieved later.
</text:p>
<text:p text:style-name="Body_20_Text">
<text:span text:style-name="Literal">'</text:span> – The closing single quote after the variable's value.
</text:p>
<text:p text:style-name="Body_20_Text">
<text:span text:style-name="Literal">,?</text:span> – Matches the optional comma at the end of the line. Similar to <text:span text:style-name="Literal">+</text:span> and <text:span text:style-name="Literal">*</text:span>, the <text:span text:style-name="Literal">?</text:span> modifier specifies "zero or one" matches.
</text:p>
<text:p text:style-name="Body_20_Text">
To use a regexp, first create a <text:span text:style-name="Literal">Pattern</text:span> object, as seen in the first line of the method. Next we will iterate through each line of the input data and attempt to match it to the <text:span text:style-name="Literal">Pattern</text:span>. Inside the loop, the <text:span text:style-name="Literal">Matcher</text:span> object handles testing the pattern. The <text:span text:style-name="Literal">matches()</text:span> method returns true if the specified <text:span text:style-name="Literal">lines[i]</text:span> value fits the pattern. Next, the <text:span text:style-name="Literal">group()</text:span> method is used to retrieve each group (which correlate to the information found inside parentheses in the pattern). The first group is the attribute (or variable name) and the second group is the value (the variable contents).
</text:p>
<text:p text:style-name="Body_20_Text">
If the line does not match, the final part of the method checks whether the line begins with a {{}}}, which specifies a break between data from two teams, at which point the values collected so far are printed to the console with <text:span text:style-name="Literal">println</text:span>.
</text:p>
<text:p text:style-name="Body_20_Text">
A complete program to acquire and parse the data for all six divisions from MLB.com follows. It creates two text files, one that contains the standings, and a second for the team codes and the team names.
</text:p>
<text:p text:style-name="Code">
import java.util.regex.*;
</text:p>
<text:p text:style-name="Code">

</text:p>
<text:p text:style-name="Code">
PrintWriter standings;
</text:p>
<text:p text:style-name="Code">
PrintWriter teams;
</text:p>
<text:p text:style-name="Code">

</text:p>
<text:p text:style-name="Code">

</text:p>
<text:p text:style-name="Code">
void setup() {
</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
String base = "http://mlb.mlb.com/components/game" +
</text:p>
<text:p text:style-name="Code">
<text:s text:c="4" />
"/year_2007/month_04/day_15/";
</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />

</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
standings = createWriter("standings.tsv");
</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
teams = createWriter("teams.tsv");
</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />

</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
parseWinLoss(loadStrings(base + "standings_rs_ale.js"));
</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
parseWinLoss(loadStrings(base + "standings_rs_alw.js"));
</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
parseWinLoss(loadStrings(base + "standings_rs_alc.js"));
</text:p>
<text:p text:style-name="Code">

</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
parseWinLoss(loadStrings(base + "standings_rs_nle.js"));
</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
parseWinLoss(loadStrings(base + "standings_rs_nlw.js"));
</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
parseWinLoss(loadStrings(base + "standings_rs_nlc.js"));
</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />

</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
// Finish writing and close each file.
</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
standings.flush();
</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
standings.close();
</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
teams.flush();
</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
teams.close();
</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />

</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
println("Done.");
</text:p>
<text:p text:style-name="Code">
}
</text:p>
<text:p text:style-name="Code">

</text:p>
<text:p text:style-name="Code">

</text:p>
<text:p text:style-name="Code">
void parseWinLoss(String[] lines) {
</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
Pattern p = Pattern.compile("\\s+([\\w\\d]+):\\s'(.*)',?");
</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />

</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
String teamCode = "";
</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
int wins = 0;
</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
int losses = 0;
</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
String teamName = "";
</text:p>
<text:p text:style-name="Code">

</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
for (int i = 0; i &lt; lines.length; i++) {
</text:p>
<text:p text:style-name="Code">
<text:s text:c="4" />
Matcher m = p.matcher(lines[i]);
</text:p>
<text:p text:style-name="Code">

</text:p>
<text:p text:style-name="Code">
<text:s text:c="4" />
if (m.matches()) {
</text:p>
<text:p text:style-name="Code">
<text:s text:c="6" />
String attr = m.group(1);
</text:p>
<text:p text:style-name="Code">
<text:s text:c="6" />
String value = m.group(2);
</text:p>
<text:p text:style-name="Code">

</text:p>
<text:p text:style-name="Code">
<text:s text:c="6" />
if (attr.equals("code")) {
</text:p>
<text:p text:style-name="Code">
<text:s text:c="8" />
teamCode = value;
</text:p>
<text:p text:style-name="Code">
<text:s text:c="6" />
} else if (attr.equals("w")) {
</text:p>
<text:p text:style-name="Code">
<text:s text:c="8" />
wins = int(value);
</text:p>
<text:p text:style-name="Code">
<text:s text:c="6" />
} else if (attr.equals("l")) {
</text:p>
<text:p text:style-name="Code">
<text:s text:c="8" />
losses = int(value);
</text:p>
<text:p text:style-name="Code">
<text:s text:c="6" />
} else if (attr.equals("league_sensitive_team_name")) {
</text:p>
<text:p text:style-name="Code">
<text:s text:c="8" />
teamName = value;
</text:p>
<text:p text:style-name="Code">
<text:s text:c="6" />
}
</text:p>
<text:p text:style-name="Code">
<text:s text:c="6" />

</text:p>
<text:p text:style-name="Code">
<text:s text:c="4" />
} else {
</text:p>
<text:p text:style-name="Code">
<text:s text:c="6" />
if (lines[i].startsWith("}")) {
</text:p>
<text:p text:style-name="Code">
<text:s text:c="8" />
// This is the end of a group, print the values
</text:p>
<text:p text:style-name="Code">
<text:s text:c="8" />
standings.println(teamCode + TAB + wins + TAB + losses);
</text:p>
<text:p text:style-name="Code">
<text:s text:c="8" />
teams.println(teamCode + TAB + teamName);
</text:p>
<text:p text:style-name="Code">
<text:s text:c="6" />
}
</text:p>
<text:p text:style-name="Code">
<text:s text:c="4" />
}
</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
}
</text:p>
<text:p text:style-name="Code">
}
</text:p>
<text:p text:style-name="Code">

</text:p>
<text:p text:style-name="Body_20_Text">
The resulting <text:span text:style-name="Filename">standings.tsv</text:span> file reads:
</text:p>
<text:p text:style-name="Code">
bos	6	4
</text:p>
<text:p text:style-name="Code">
tor	7	5
</text:p>
<text:p text:style-name="Code">
bal	6	6
</text:p>
<text:p text:style-name="Code">
nyy	5	6
</text:p>
<text:p text:style-name="Code">
tb	5	7
</text:p>
<text:p text:style-name="Code">
sea	5	3
</text:p>
<text:p text:style-name="Code">
ana	6	6
</text:p>
<text:p text:style-name="Code">
oak	6	7
</text:p>
<text:p text:style-name="Code">
tex	5	7
</text:p>
<text:p text:style-name="Code">
cle	6	3
</text:p>
<text:p text:style-name="Code">
det	7	5
</text:p>
<text:p text:style-name="Code">
min	7	5
</text:p>
<text:p text:style-name="Code">
cws	5	6
</text:p>
<text:p text:style-name="Code">
kc	3	9
</text:p>
<text:p text:style-name="Code">
atl	8	3
</text:p>
<text:p text:style-name="Code">
nym	7	4
</text:p>
<text:p text:style-name="Code">
fla	6	5
</text:p>
<text:p text:style-name="Code">
phi	3	8
</text:p>
<text:p text:style-name="Code">
was	3	9
</text:p>
<text:p text:style-name="Code">
ari	9	4
</text:p>
<text:p text:style-name="Code">
la	8	4
</text:p>
<text:p text:style-name="Code">
sd	7	5
</text:p>
<text:p text:style-name="Code">
col	5	7
</text:p>
<text:p text:style-name="Code">
sf	3	7
</text:p>
<text:p text:style-name="Code">
cin	7	5
</text:p>
<text:p text:style-name="Code">
mil	6	5
</text:p>
<text:p text:style-name="Code">
stl	6	5
</text:p>
<text:p text:style-name="Code">
hou	4	6
</text:p>
<text:p text:style-name="Code">
pit	4	6
</text:p>
<text:p text:style-name="Code">
chc	4	7
</text:p>
<text:p text:style-name="Body_20_Text">
And the <text:span text:style-name="Filename">teams.tsv</text:span> file contains:
</text:p>
<text:p text:style-name="Code">
bos	Boston
</text:p>
<text:p text:style-name="Code">
tor	Toronto
</text:p>
<text:p text:style-name="Code">
bal	Baltimore
</text:p>
<text:p text:style-name="Code">
nyy	NY Yankees
</text:p>
<text:p text:style-name="Code">
tb	Tampa Bay
</text:p>
<text:p text:style-name="Code">
sea	Seattle
</text:p>
<text:p text:style-name="Code">
ana	LA Angels
</text:p>
<text:p text:style-name="Code">
oak	Oakland
</text:p>
<text:p text:style-name="Code">
tex	Texas
</text:p>
<text:p text:style-name="Code">
cle	Cleveland
</text:p>
<text:p text:style-name="Code">
det	Detroit
</text:p>
<text:p text:style-name="Code">
min	Minnesota
</text:p>
<text:p text:style-name="Code">
cws	Chi White Sox
</text:p>
<text:p text:style-name="Code">
kc	Kansas City
</text:p>
<text:p text:style-name="Code">
atl	Atlanta
</text:p>
<text:p text:style-name="Code">
nym	NY Mets
</text:p>
<text:p text:style-name="Code">
fla	Florida
</text:p>
<text:p text:style-name="Code">
phi	Philadelphia
</text:p>
<text:p text:style-name="Code">
was	Washington
</text:p>
<text:p text:style-name="Code">
ari	Arizona
</text:p>
<text:p text:style-name="Code">
la	LA Dodgers
</text:p>
<text:p text:style-name="Code">
sd	San Diego
</text:p>
<text:p text:style-name="Code">
col	Colorado
</text:p>
<text:p text:style-name="Code">
sf	San Francisco
</text:p>
<text:p text:style-name="Code">
cin	Cincinnati
</text:p>
<text:p text:style-name="Code">
mil	Milwaukee
</text:p>
<text:p text:style-name="Code">
stl	St. Louis
</text:p>
<text:p text:style-name="Code">
hou	Houston
</text:p>
<text:p text:style-name="Code">
pit	Pittsburgh
</text:p>
<text:p text:style-name="Code">
chc	Chi Cubs
</text:p>
<text:p text:style-name="Body_20_Text">
The team names file can be downloaded here:
</text:p>
<text:p text:style-name="Text_20_body_20_indent">
<text:span text:style-name="Hyperlink">
http://benfry.com/book/salaryper/teams.tsv
</text:span>
</text:p>
<text:p text:style-name="Body_20_Text">
along with the example standings file:
</text:p>
<text:p text:style-name="Text_20_body_20_indent">
<text:span text:style-name="Hyperlink">
http://benfry.com/book/salaryper/standings.tsv
</text:span>
</text:p>
<text:p text:style-name="Body_20_Text">
The code downloads each file for April 15, 2007, but changing to another date is a simple matter. To use the current date, use a combination of the <text:span text:style-name="Literal">year()</text:span>, <text:span text:style-name="Literal">month()</text:span>, and <text:span text:style-name="Literal">day()</text:span> methods along with <text:span text:style-name="Literal">nf()</text:span> to pad the numbers to the proper number of digits:
</text:p>
<text:p text:style-name="Code">
String base = "http://mlb.mlb.com/components/game" +
</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
"/year_" + nf(year(), 4) +
</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
"/month_" + nf(month(), 2) +
</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
"/day_" + nf(day(), 2) + "/";
</text:p>
<text:p text:style-name="Heading_20_1">Preprocessing: Acquiring Team Logos (Acquire, Refine)</text:p>
<text:p text:style-name="Body_20_Text">
Plain text for the team names is not particularly appealing, it's much more temping to use the actual team logos because they're so closely associated with each team. Finding team logos on the MLB site (or any other site, for that matter) illustrates another bit of useful detective work, in this case trying to determine the pattern for a series of image files.
</text:p>
<text:p text:style-name="Body_20_Text">
The first thing to do is to find a possible logo image. For instance, the scoreboard page at <text:span text:style-name="Literal">http://mlb.mlb.com/mlb/scoreboard</text:span> has logos for several of the teams. To determine their location, right-click one of the images, and select Copy Image Location (or its equivalent in whatever web browser you are using), and use that location to open a new page. Right-clicking on the Chicago Cubs image, for instance, produced this URL:
</text:p>
<text:p text:style-name="Text_20_body_20_indent">
<text:span text:style-name="Hyperlink">
http://mlb.mlb.com/mlb/images/team_logos/logo_chc_small.gif
</text:span>
</text:p>
<text:p text:style-name="Body_20_Text">
The <text:span text:style-name="Literal">chc</text:span> is the three letter team code found earlier when downloading team data, which suggests that logos for the remaining 29 teams can be found by replacing those three letters for each team. The list of codes is one column of the <text:span text:style-name="Filename">teams.tsv</text:span> file created in the previous step. In a new sketch, enter the team codes as part of a <text:span text:style-name="Literal">String</text:span> array. Put quotes around each to specify that they are <text:span text:style-name="Literal">String</text:span> objects, and commas between each to set apart the list. The following syntax shows how to create a String array already populated information (rather than loading it from a file).
</text:p>
<text:p text:style-name="Code">
String[] teams = {
</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
"ana", "ari", "atl", "bal", "bos", "chc", "cin", "cle",
</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
"col", "cws", "det", "fla", "hou", "kc", "la", "mil",
</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
"min", "nym", "nyy", "oak", "phi", "pit", "sd",
</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
"sea", "sf", "stl", "tb", "tex", "tor", "was"
</text:p>
<text:p text:style-name="Code">
};
</text:p>
<text:p text:style-name="Body_20_Text">
The fact that the file name includes <text:span text:style-name="Filename">_small</text:span> in the title suggests that there are images of other sizes. A first thing to try suffixes like <text:span text:style-name="Filename">_large</text:span> or <text:span text:style-name="Filename">_medium</text:span>, though neither work in this situation. It may be possible to even look at the directory that contains the logos (<text:span text:style-name="Literal">http://mlb.mlb.com/mlb/images/team_logos/</text:span>) and get a file listing, but this generally only works for smaller (or less professional) web sites.
</text:p>
<text:p text:style-name="Body_20_Text">
Of course, the locations for the images are subject to change at any time (and often will), which is why we are spending time to go through the process of figuring out the image locations.
</text:p>
<text:p text:style-name="Body_20_Text">
The next alternative to finding other images (aside from digging around the site for images in other shapes and sizes) is to use a search engine. Do a search for the first part of the URL and see what sort of results turn up. Doing a search for <text:span text:style-name="Literal">mlb/images/team_logos/</text:span> reveals several additional possibilities:
</text:p>
<text:p text:style-name="Text_20_body_20_indent">
<text:span text:style-name="Hyperlink">
http://mlb.mlb.com/mlb/images/team_logos/logo_atl_small.gif
</text:span>
</text:p>
<text:p text:style-name="Text_20_body_20_indent">
<text:span text:style-name="Hyperlink">
http://mlb.mlb.com/mlb/images/team_logos/50x50/atl.gif
</text:span>
</text:p>
<text:p text:style-name="Text_20_body_20_indent">
<text:span text:style-name="Hyperlink">
http://mlb.mlb.com/mlb/images/team_logos/logo_bal_79x76.jpg
</text:span>
</text:p>
<text:p text:style-name="Text_20_body_20_indent">
<text:span text:style-name="Hyperlink">
http://mlb.mlb.com/mlb/images/team_logos/51x21/bos_standings_logo.gif
</text:span>
</text:p>
<text:p text:style-name="Body_20_Text">
A fifth on another site shows yet another format:
</text:p>
<text:p text:style-name="Text_20_body_20_indent">
<text:span text:style-name="Hyperlink">
http://losangeles.angels.mlb.com/mlb/images/team_logos/100x100/ana.gif
</text:span>
</text:p>
<text:p text:style-name="Body_20_Text">
Though the similarities in the directory structure suggest that the site is merely an alias, and a quick test confirms that the following works in an identical manner:
</text:p>
<text:p text:style-name="Text_20_body_20_indent">
<text:span text:style-name="Hyperlink">
http://mlb.mlb.com/mlb/images/team_logos/100x100/ana.gif
</text:span>
</text:p>
<text:p text:style-name="Body_20_Text">
For each of the URLs in question, the team code is used between a prefix and suffix specific to the image size and location. In the case of the small logos, the prefix is the following:
</text:p>
<text:p text:style-name="Text_20_body_20_indent">
<text:span text:style-name="Hyperlink">
http://mlb.mlb.com/mlb/images/team_logos/logo_
</text:span>
</text:p>
<text:p text:style-name="Body_20_Text">
followed by the two or three digit team code, and the suffix:
</text:p>
<text:p text:style-name="Code">
_small.gif
</text:p>
<text:p text:style-name="Body_20_Text">
With all this in mind, a short program can be used to download each set of images:
</text:p>
<text:p text:style-name="Code">
String[] teams = {
</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
"ana", "ari", "atl", "bal", "bos", "chc", "cin", "cle",
</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
"col", "cws", "det", "fla", "hou", "kc", "la", "mil",
</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
"min", "nym", "nyy", "oak", "phi", "pit", "sd",
</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
"sea", "sf", "stl", "tb", "tex", "tor", "was"
</text:p>
<text:p text:style-name="Code">
};
</text:p>
<text:p text:style-name="Code">

</text:p>
<text:p text:style-name="Code">
void setup() {
</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
grabLogos("small", "http://mlb.mlb.com/mlb/images/team_logos/logo_", "_small.gif");
</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
grabLogos("50x50", "http://mlb.mlb.com/mlb/images/team_logos/50x50/", ".gif");
</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
grabLogos("79x76", "http://mlb.mlb.com/mlb/images/team_logos/logo_", "_79x76.jpg");
</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
grabLogos("standings", "http://mlb.mlb.com/mlb/images/team_logos/51x21/", "_standings_logo.gif");
</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
grabLogos("100x100", "http://mlb.mlb.com/mlb/images/team_logos/100x100/", ".gif");
</text:p>
<text:p text:style-name="Code">
}
</text:p>
<text:p text:style-name="Code">

</text:p>
<text:p text:style-name="Code">
void grabLogos(String folder, String prefix, String suffix) {
</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
String extension = suffix.substring(suffix.length() - 4);
</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
for (int i = 0; i &lt; teams.length; i++) {
</text:p>
<text:p text:style-name="Code">
<text:s text:c="4" />
String filename = folder + "/" + teams[i] + extension;
</text:p>
<text:p text:style-name="Code">
<text:s text:c="4" />
String url = prefix + teams[i] + suffix;
</text:p>
<text:p text:style-name="Code">
<text:s text:c="4" />
println("Downloading " + url);
</text:p>
<text:p text:style-name="Code">
<text:s text:c="4" />
saveStream(filename, url);
</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
}
</text:p>
<text:p text:style-name="Code">
}
</text:p>
<text:p text:style-name="Body_20_Text">
The <text:span text:style-name="Literal">teams</text:span> array contains the list of the 30 team codes. The <text:span text:style-name="Literal">grabLogos()</text:span> method iterates through each team, downloading images based on the specified prefix and suffix. The <text:span text:style-name="Literal">saveStream()</text:span> method handles loading the data available at a particular web address and writing it back to the disk (it's equivalent to using the built-in function <text:span text:style-name="Literal">loadBytes()</text:span>, followed by <text:span text:style-name="Literal">saveBytes()</text:span>). Because the image may be a <text:span text:style-name="Filename">.jpg</text:span> or <text:span text:style-name="Filename">.gif</text:span> file, the <text:span text:style-name="Literal">grabLogos()</text:span> method uses <text:span text:style-name="Literal">substring()</text:span> on the source file name to determine the extension to use when naming the downloaded file.
</text:p>
<text:p text:style-name="Body_20_Text">
In the end, the <text:span text:style-name="Filename">small</text:span> directory contains the most promising images (in terms of size and proportion). Start a new sketch, and use Sketch -&gt; Show Sketch Folder. to add these to the <text:span text:style-name="Filename">data</text:span> folder.
</text:p>
<text:p text:style-name="Heading_20_1">Preprocessing: Acquiring and Parsing Salary Data (Acquire, Parse, Filter)</text:p>
<text:p text:style-name="Body_20_Text">
The next step is to find a list of the payroll for each of the teams. There appears to be no such feature on MLB.com, but the USA Today web site makes available a list of team payrolls here:
</text:p>
<text:p text:style-name="Text_20_body_20_indent">
<text:span text:style-name="Hyperlink">
http://usatoday.com/sports/baseball/salaries/totalpayroll.aspx?year=2007
</text:span>
</text:p>
<text:p text:style-name="Body_20_Text">
The simplest method to get this information is to copy from your web browser and paste into an open document in your spreadsheet application of choice. If you're lucky, the table will be interpreted as tab delimited, so the columns will be preserved when pasting into the spreadsheet.
</text:p>
<text:p text:style-name="Body_20_Text">
Another option is to use the import or link feature of your spreadsheet application. For instance, if using OpenOffice.org, create a new Calc document, and choose Insert -&gt; Link To External Data... Paste the URL found above into the first text field that reads "URL of external data source." Pressing the enter (or return) key will populate the list of "Available tables/ranges." Scroll down and select <text:span text:style-name="Filename">HTML__BBSalTable</text:span> from the list.
</text:p>
<text:p text:style-name="Body_20_Text">
Figure 02
</text:p>
<text:p text:style-name="Body_20_Text">
Click OK to import the data. This will pick up more of the web page than necessary, but scrolling down to the 17th row and expanding columns A and B shows the list of teams:
</text:p>
<text:p text:style-name="Body_20_Text">
Figure 03
</text:p>
<text:p text:style-name="Body_20_Text">
Delete all rows and columns except for the team name and the salary, and replace each team name with its two or three letter code. The commas and dollar signs will also need to be removed (a quick Find &amp; Replace will take care of these). Finally, save the file as plain text in TSV format as <text:span text:style-name="Filename">salaries.tsv</text:span>. A completed version of the salaries file can be found here:
</text:p>
<text:p text:style-name="Text_20_body_20_indent">
<text:span text:style-name="Hyperlink">
http://benfry.com/book/salaryper/salaries.tsv
</text:span>
</text:p>
<text:p text:style-name="Body_20_Text">
Of course, parsing the page and downloading the table could be handled in code, but the amount of information (30 team salaries) and the frequency at which it's updated (once a year) does not warrant an algorithmic solution. 
</text:p>
<text:p text:style-name="Body_20_Text">
[BOX] As a rule of thumb, I will only write code in cases where the time to write the code is less than (or equal to) double the amount of time it takes to do the process by hand. That is, if it takes three hours to do it by hand, and I can implement it in code in six hours or less, then code is preferred so that it can be easily updated. As a corollary, however, in situations like this one, the page structure will likely change more than the data itself. In such cases, writing a parser is usually a waste of time.
</text:p>
<text:p text:style-name="Heading_20_1">Starting the actual program (Acquire, Parse, Filter, Mine)</text:p>
<text:p text:style-name="Body_20_Text">
In the previous steps, we've managed to download files that represent the team names and logos, their salaries, and their standings on a given day. Having determined how to handle each type of information, and preprocessed parts of the information, we'll next pull it together into a single application.
</text:p>
<text:p text:style-name="Body_20_Text">
Team Names and Codes
</text:p>
<text:p text:style-name="Body_20_Text">
We'll first load the team names using a method named <text:span text:style-name="Literal">setupTeams()</text:span>. This is similar to other examples where <text:span text:style-name="Literal">loadStrings()</text:span> is used, followed by <text:span text:style-name="Literal">split()</text:span> to break a line into individual columns.
</text:p>
<text:p text:style-name="Code">
int teamCount = 30;
</text:p>
<text:p text:style-name="Code">
String[] teamNames;
</text:p>
<text:p text:style-name="Code">
String[] teamCodes;
</text:p>
<text:p text:style-name="Code">
HashMap teamIndices;
</text:p>
<text:p text:style-name="Code">

</text:p>
<text:p text:style-name="Code">
void setupTeams() {
</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
String[] lines = loadStrings("teams.tsv");
</text:p>
<text:p text:style-name="Code">
<text:s text:c="4" />

</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
teamCount = lines.length;
</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
teamCodes = new String[teamCount];
</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
teamNames = new String[teamCount];
</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
teamIndices = new HashMap();
</text:p>
<text:p text:style-name="Code">
<text:s text:c="4" />

</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
for (int i = 0; i &lt; teamCount; i++) {
</text:p>
<text:p text:style-name="Code">
<text:s text:c="4" />
String[] pieces = split(lines[i], TAB);
</text:p>
<text:p text:style-name="Code">
<text:s text:c="4" />
teamCodes[i] = pieces[0];
</text:p>
<text:p text:style-name="Code">
<text:s text:c="4" />
teamNames[i] = pieces[1];
</text:p>
<text:p text:style-name="Code">
<text:s text:c="4" />
teamIndices.put(teamCodes[i], new Integer(i));
</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
}
</text:p>
<text:p text:style-name="Code">
}
</text:p>
<text:p text:style-name="Code">

</text:p>
<text:p text:style-name="Code">
int teamIndex(String teamCode) {
</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
Integer index = (Integer) teamIndices.get(teamCode);
</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
return index.intValue();
</text:p>
<text:p text:style-name="Code">
}
</text:p>
<text:p text:style-name="Body_20_Text">
Most important for the <text:span text:style-name="Literal">teamCodes</text:span> and <text:span text:style-name="Literal">teamNames</text:span> arrays is that they provide an ordering that can be used to anchor the data. That is, when the salary information is loaded, there is no way to know the exact order in which the teams will be found. The same is true for the win-loss standings, which will change from day to day. By mapping the <text:span text:style-name="Literal">teamCode</text:span> to a particular team index (numbered 0 to 29), we can always ensure that data from each source is connected properly.
</text:p>
<text:p text:style-name="Body_20_Text">
To map a <text:span text:style-name="Literal">teamCode</text:span> to an integer index, a <text:span text:style-name="Literal">HashMap</text:span> is used. The <text:span text:style-name="Literal">HashMap</text:span> class like a dictionary that connects two pieces of data, each an <text:span text:style-name="Literal">Object</text:span>. The <text:span text:style-name="Literal">put()</text:span> method adds a new entry to the map, while the <text:span text:style-name="Literal">get()</text:span> method retrieves it. Because only objects can be used in <text:span text:style-name="Literal">HashMap</text:span>s, it's necessary to wrap the <text:span text:style-name="Literal">int</text:span> for the team's index in an <text:span text:style-name="Literal">Integer</text:span> object, which was created for this purpose. The <text:span text:style-name="Literal">intValue()</text:span> method extracts the original <text:span text:style-name="Literal">int</text:span> from the <text:span text:style-name="Literal">Integer</text:span> object. This is encapsulated by the <text:span text:style-name="Literal">teamIndex</text:span> function, so that we don't have to think about <text:span text:style-name="Literal">HashMap</text:span>s or <text:span text:style-name="Literal">Integer</text:span>s when writing the rest of the code.
</text:p>
<text:p text:style-name="Body_20_Text">
[BOX] What's the difference between <text:span text:style-name="Literal">int</text:span> and <text:span text:style-name="Literal">Integer</text:span>? An <text:span text:style-name="Literal">int</text:span> is a primitive type (like <text:span text:style-name="Literal">float</text:span> and <text:span text:style-name="Literal">char</text:span>), which contains an actual literal value, as opposed to an object, which is a reference to a block of related values. The distinction can be confusing, and often leads people to ask why not make everything an object? The answer is that objects create significant (and unnecessary) overhead for the purposes of how primitive types like <text:span text:style-name="Literal">int</text:span> are used. For example, in a <text:span text:style-name="Literal">for</text:span> loop with thousands of iterations, it would be silly to de-reference an <text:span text:style-name="Literal">Integer</text:span> object used for the counter on each iteration. Because the <text:span text:style-name="Literal">int</text:span> refers to specific value, only one step is required to read or change it. The object refers to a location in memory, so the first step would be to check whether the location was valid. The number might be stored in a variable called <text:span text:style-name="Literal">value</text:span>, so once the location in memory was determined to be correct, a check would be made to find the location of the <text:span text:style-name="Literal">value</text:span> variable (and whether or not it existed). Then, the variable itself could be manipulated in some manner. While it may not sound like much, this sort of thing really makes a difference when dealing with thousands of values. Scripting languages often use objects for all values, which can contribute to their lack of speed. Especially in cases of languages that are not "typed," that each piece of data must first be converted as it is used. That is, everything might be stored as string values, and then converted to an integer in any context where the value is used as an integer (such as counting in our <text:span text:style-name="Literal">for</text:span> loop). The process can be even more time consuming.
</text:p>
<text:p text:style-name="Body_20_Text">
Team Salaries
</text:p>
<text:p text:style-name="Body_20_Text">
The salary data will be a list of ranked values, just like the team standings information. The parameters for ranked data will be:
</text:p>
<text:p text:style-name="Body_20_Text">
A list of the values to be ranked (the amount of each teams' payroll)
</text:p>
<text:p text:style-name="Body_20_Text">
A list of how those values will be shown to the user (the number formatted as a dollar amount, with commas: $34,140,182).
</text:p>
<text:p text:style-name="Body_20_Text">
A list of the rank for each item, and a sorting order to be used when ranking. For instance, a higher payroll amount has a negative connotation, whereas a higher win-loss average has a positive connotation. In some cases having the data in ascending order might be more useful, others will be the opposite.
</text:p>
<text:p text:style-name="Body_20_Text">
A means of keeping track of the highest and lowest values.
</text:p>
<text:p text:style-name="Body_20_Text">
The ranked list is useful for salary data as well as the win-loss standings. It will also be useful when adapting this project to other types of data. Because it also requires a little bit of code to sort the information and calculate its minimum and maximum values, the <text:span text:style-name="Literal">RankedList</text:span> class was created to provide a general purpose means of handling ranked data. Download this class from the book site and add it to your sketch:
</text:p>
<text:p text:style-name="Text_20_body_20_indent">
<text:span text:style-name="Hyperlink">
http://benfry.com/book/salaryper/RankedList.java
</text:span>
</text:p>
<text:p text:style-name="Body_20_Text">
The parameters described above are stored in the <text:span text:style-name="Literal">value</text:span>, <text:span text:style-name="Literal">title</text:span>, and <text:span text:style-name="Literal">rank</text:span> arrays. To use the class for salary data, one need only <text:span text:style-name="Technical_20_Italic">extend</text:span> the class. To do this, create a <text:span text:style-name="Literal">SalaryList</text:span> class in a new tab. Its only contents are:
</text:p>
<text:p text:style-name="Code">
class SalaryList extends RankedList {
</text:p>
<text:p text:style-name="Code">
<text:s text:c="4" />

</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
SalaryList(String[] lines) {
</text:p>
<text:p text:style-name="Code">
<text:s text:c="4" />
super(teamCount, false);
</text:p>
<text:p text:style-name="Code">
<text:s text:c="4" />

</text:p>
<text:p text:style-name="Code">
<text:s text:c="4" />
for (int i = 0; i &lt; teamCount; i++) {
</text:p>
<text:p text:style-name="Code">
<text:s text:c="6" />
String pieces[] = split(lines[i], TAB);
</text:p>
<text:p text:style-name="Code">
<text:s text:c="8" />

</text:p>
<text:p text:style-name="Code">
<text:s text:c="6" />
// First column is the team 2-3 digit team code.
</text:p>
<text:p text:style-name="Code">
<text:s text:c="6" />
int index = teamIndex(pieces[0]);
</text:p>
<text:p text:style-name="Code">
<text:s text:c="8" />

</text:p>
<text:p text:style-name="Code">
<text:s text:c="6" />
// Second column is the salary as a number.
</text:p>
<text:p text:style-name="Code">
<text:s text:c="6" />
value[index] = parseInt(pieces[1]);
</text:p>
<text:p text:style-name="Code">
<text:s text:c="8" />

</text:p>
<text:p text:style-name="Code">
<text:s text:c="6" />
// Make the title in the format $NN,NNN,NNN
</text:p>
<text:p text:style-name="Code">
<text:s text:c="6" />
int salary = (int) value[index];
</text:p>
<text:p text:style-name="Code">
<text:s text:c="6" />
title[index] = "$" + nfc(salary);
</text:p>
<text:p text:style-name="Code">
<text:s text:c="4" />
}
</text:p>
<text:p text:style-name="Code">
<text:s text:c="4" />
update();
</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
}
</text:p>
<text:p text:style-name="Code">
}
</text:p>
<text:p text:style-name="Body_20_Text">
The <text:span text:style-name="Literal">SalaryList</text:span> method is the constructor for the class, it controls how an object is initialized. The <text:span text:style-name="Literal">super</text:span> method calls the constructor of the parent class (known as the <text:span text:style-name="Technical_20_Italic">superclass</text:span>). In this case, it runs <text:span text:style-name="Literal">RankedList(teamCount, false)</text:span> to create a list with 30 entries in descending order (the <text:span text:style-name="Literal">false</text:span> specifes not in ascending order).
</text:p>
<text:p text:style-name="Body_20_Text">
The rest of the code is like our other parsing functions, except that it fills the <text:span text:style-name="Literal">value</text:span>, <text:span text:style-name="Literal">title</text:span>, and <text:span text:style-name="Literal">rank</text:span> array for the values read from an array of <text:span text:style-name="Literal">String</text:span>s loaded from a file. The <text:span text:style-name="Literal">title</text:span> variable for each is set to a dollar sign followed by the payroll number with commas inserted by the <text:span text:style-name="Literal">nfc()</text:span> method.
</text:p>
<text:p text:style-name="Body_20_Text">
After parsing the information, the <text:span text:style-name="Literal">update()</text:span> method calls a function inside <text:span text:style-name="Literal">RankedList</text:span> that takes care of sorting the data and calculating the minimum and maximum values.
</text:p>
<text:p text:style-name="Body_20_Text">
Back in the main tab, the <text:span text:style-name="Literal">setupSalaries()</text:span> method creates the <text:span text:style-name="Literal">SalaryList</text:span>.
</text:p>
<text:p text:style-name="Code">
SalaryList salaries;
</text:p>
<text:p text:style-name="Code">

</text:p>
<text:p text:style-name="Code">
void setupSalaries() {
</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
String[] lines = loadStrings("salaries.tsv");
</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
salaries = new SalaryList(lines);
</text:p>
<text:p text:style-name="Code">
}
</text:p>
<text:p text:style-name="Body_20_Text">
Win-Loss Standings
</text:p>
<text:p text:style-name="Body_20_Text">
The win-loss record is handled in a similar fashion. First, a modified version of our pre-processing code handles acquiring and parsing the standings data for a given day:
</text:p>
<text:p text:style-name="Code">
String[] acquireStandings(int year, int month, int day) {
</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
String filename = year + nf(month, 2) + nf(day, 2) + ".tsv";
</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
String path = dataPath(filename);
</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
File file = new File(path);
</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
if (!file.exists() || (file.length() == 0)) {
</text:p>
<text:p text:style-name="Code">
<text:s text:c="4" />
println("Downloading standings file " + filename);
</text:p>
<text:p text:style-name="Code">
<text:s text:c="4" />
PrintWriter writer = createWriter(path);
</text:p>
<text:p text:style-name="Code">

</text:p>
<text:p text:style-name="Code">
<text:s text:c="4" />
String base = "http://mlb.mlb.com/components/game" +
</text:p>
<text:p text:style-name="Code">
<text:s text:c="6" />
"/year_" + year + "/month_" + nf(month, 2) + "/day_" + nf(day, 2) + "/";
</text:p>
<text:p text:style-name="Code">

</text:p>
<text:p text:style-name="Code">
<text:s text:c="4" />
// American League (AL)
</text:p>
<text:p text:style-name="Code">
<text:s text:c="4" />
parseStandings(base + "standings_rs_ale.js", writer);
</text:p>
<text:p text:style-name="Code">
<text:s text:c="4" />
parseStandings(base + "standings_rs_alc.js", writer);
</text:p>
<text:p text:style-name="Code">
<text:s text:c="4" />
parseStandings(base + "standings_rs_alw.js", writer);
</text:p>
<text:p text:style-name="Code">

</text:p>
<text:p text:style-name="Code">
<text:s text:c="4" />
// National League (NL)
</text:p>
<text:p text:style-name="Code">
<text:s text:c="4" />
parseStandings(base + "standings_rs_nle.js", writer);
</text:p>
<text:p text:style-name="Code">
<text:s text:c="4" />
parseStandings(base + "standings_rs_nlc.js", writer);
</text:p>
<text:p text:style-name="Code">
<text:s text:c="4" />
parseStandings(base + "standings_rs_nlw.js", writer);
</text:p>
<text:p text:style-name="Code">

</text:p>
<text:p text:style-name="Code">
<text:s text:c="4" />
writer.flush();
</text:p>
<text:p text:style-name="Code">
<text:s text:c="4" />
writer.close();
</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
}
</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
return loadStrings(filename);
</text:p>
<text:p text:style-name="Code">
}
</text:p>
<text:p text:style-name="Code">

</text:p>
<text:p text:style-name="Code">
void parseStandings(String filename, PrintWriter writer) {
</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
String[] lines = loadStrings(filename);
</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
Pattern p = Pattern.compile("\\s+([\\w\\d]+):\\s'(.*)',?");
</text:p>
<text:p text:style-name="Code">

</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
String teamCode = "";
</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
int wins = 0;
</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
int losses = 0;
</text:p>
<text:p text:style-name="Code">

</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
for (int i = 0; i &lt; lines.length; i++) {
</text:p>
<text:p text:style-name="Code">
<text:s text:c="4" />
Matcher m = p.matcher(lines[i]);
</text:p>
<text:p text:style-name="Code">

</text:p>
<text:p text:style-name="Code">
<text:s text:c="4" />
if (m.matches()) {
</text:p>
<text:p text:style-name="Code">
<text:s text:c="6" />
String attr = m.group(1);
</text:p>
<text:p text:style-name="Code">
<text:s text:c="6" />
String value = m.group(2);
</text:p>
<text:p text:style-name="Code">

</text:p>
<text:p text:style-name="Code">
<text:s text:c="6" />
if (attr.equals("code")) {
</text:p>
<text:p text:style-name="Code">
<text:s text:c="8" />
teamCode = value;
</text:p>
<text:p text:style-name="Code">
<text:s text:c="6" />
} else if (attr.equals("w")) {
</text:p>
<text:p text:style-name="Code">
<text:s text:c="8" />
wins = parseInt(value);
</text:p>
<text:p text:style-name="Code">
<text:s text:c="6" />
} else if (attr.equals("l")) {
</text:p>
<text:p text:style-name="Code">
<text:s text:c="8" />
losses = parseInt(value);
</text:p>
<text:p text:style-name="Code">
<text:s text:c="6" />
}
</text:p>
<text:p text:style-name="Code">

</text:p>
<text:p text:style-name="Code">
<text:s text:c="4" />
} else {
</text:p>
<text:p text:style-name="Code">
<text:s text:c="6" />
if (lines[i].startsWith("}")) {
</text:p>
<text:p text:style-name="Code">
<text:s text:c="8" />
// This is the end of a group, write these values
</text:p>
<text:p text:style-name="Code">
<text:s text:c="8" />
writer.println(teamCode + TAB + wins + TAB + losses);
</text:p>
<text:p text:style-name="Code">
<text:s text:c="6" />
}
</text:p>
<text:p text:style-name="Code">
<text:s text:c="4" />
}
</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
}
</text:p>
<text:p text:style-name="Code">
}
</text:p>
<text:p text:style-name="Body_20_Text">
For data from May 2, 2007, the <text:span text:style-name="Literal">acquireStandings()</text:span> method looks for a file named <text:span text:style-name="Filename">20070502.tsv</text:span>. If the file is not present, it downloads the data from MLB.com and parses it to create a filtered version that contains only the team code followed by the number of wins and then the number of losses.
</text:p>
<text:p text:style-name="Body_20_Text">
This code is nearly identical to the standalone version discussed earlier in the pre-processing steps. One difference is the use of a <text:span text:style-name="Literal">File</text:span> object and the <text:span text:style-name="Literal">dataPath()</text:span> method. The <text:span text:style-name="Literal">dataPath()</text:span> method gives a full path name to a file found in the <text:span text:style-name="Filename">data</text:span> directory. This is useful when interfacing between Processing and Java file methods, because Java has no concept of the <text:span text:style-name="Filename">data</text:span> folder. The <text:span text:style-name="Literal">File</text:span> class is used in Java to store a reference to a particular file (or directory), and includes several useful methods like <text:span text:style-name="Literal">exists()</text:span>, which we use here to determine whether the file is available or not. Here we also check to see if the file's length (size) is zero, which can happen if the <text:span text:style-name="Literal">acquireStandings</text:span> method is interrupted, and the file is not completely written.
</text:p>
<text:p text:style-name="Body_20_Text">
In a new tab called <text:span text:style-name="Filename">StandingsList</text:span>, write a similar piece of code to the constructor for <text:span text:style-name="Literal">SalaryList</text:span>.
</text:p>
<text:p text:style-name="Code">
class StandingsList extends RankedList {
</text:p>
<text:p text:style-name="Code">
<text:s text:c="4" />

</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
StandingsList(String[] lines) {
</text:p>
<text:p text:style-name="Code">
<text:s text:c="4" />
super(teamCount, false);
</text:p>
<text:p text:style-name="Code">
<text:s text:c="6" />

</text:p>
<text:p text:style-name="Code">
<text:s text:c="4" />
for (int i = 0; i &lt; teamCount; i++) {
</text:p>
<text:p text:style-name="Code">
<text:s text:c="6" />
String[] pieces = split(lines[i], TAB);
</text:p>
<text:p text:style-name="Code">
<text:s text:c="6" />
int index = teamIndex(pieces[0]);
</text:p>
<text:p text:style-name="Code">
<text:s text:c="6" />
int wins = parseInt(pieces[1]);
</text:p>
<text:p text:style-name="Code">
<text:s text:c="6" />
int losses = parseInt(pieces[2]);
</text:p>
<text:p text:style-name="Code">
<text:s text:c="8" />

</text:p>
<text:p text:style-name="Code">
<text:s text:c="6" />
value[index] = (float) wins / (float) (wins+losses);
</text:p>
<text:p text:style-name="Code">
<text:s text:c="6" />
title[index] = wins + "-" + losses;
</text:p>
<text:p text:style-name="Code">
<text:s text:c="4" />
}
</text:p>
<text:p text:style-name="Code">
<text:s text:c="4" />
update();
</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
}
</text:p>
<text:p text:style-name="Code">
}
</text:p>
<text:p text:style-name="Body_20_Text">
And back in the main tab, loading the data works similarly, where standings information is acquired based on the current day.
</text:p>
<text:p text:style-name="Code">
StandingsList standings;
</text:p>
<text:p text:style-name="Code">

</text:p>
<text:p text:style-name="Code">
void setupStandings() {
</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
String[] lines = acquireStandings(year(), month(), day());
</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
standings = new StandingsList(lines);
</text:p>
<text:p text:style-name="Code">
}
</text:p>
<text:p text:style-name="Body_20_Text">
Team Logos
</text:p>
<text:p text:style-name="Body_20_Text">
All that remains now is to load the logo images for each team. These were downloaded earlier in the preprocessing step into a folder named <text:span text:style-name="Filename">small</text:span>. Add this folder to the data folder of your sketch, and the following code to your program:
</text:p>
<text:p text:style-name="Code">
PImage[] logos;
</text:p>
<text:p text:style-name="Code">
float logoWidth;
</text:p>
<text:p text:style-name="Code">
float logoHeight;
</text:p>
<text:p text:style-name="Code">

</text:p>
<text:p text:style-name="Code">
void setupLogos() {
</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
logos = new PImage[teamCount];
</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
for (int i = 0; i &lt; teamCount; i++) {
</text:p>
<text:p text:style-name="Code">
<text:s text:c="4" />
logos[i] = loadImage("small/" + teamCodes[i] + ".gif");
</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
}
</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
logoWidth = logos[0].width / 2.0;
</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
logoHeight = logos[0].height / 2.0;
</text:p>
<text:p text:style-name="Code">
}
</text:p>
<text:p text:style-name="Body_20_Text">
This gets into how the logos are represented as well. Each logo is 38 pixels wide and 45 pixels tall. Some quick math will tell us that 45 pixels times 30 teams (1350 pixels) will not fit on the screen, or at least is unnecessarily large. However, half that height is just perfect for a 1024x768 display. Because the size of the logo images might change over the years (or with a different data set), the <text:span text:style-name="Literal">logoWidth</text:span> and <text:span text:style-name="Literal">logoHeight</text:span> variables are determined by using half the size of the first logo that is loaded.
</text:p>
<text:p text:style-name="Body_20_Text">
Finishing <text:span text:style-name="Literal">setup()</text:span>
</text:p>
<text:p text:style-name="Body_20_Text">
The <text:span text:style-name="Literal">setup()</text:span> method brings all this together and also sets up a font to use for showing the data. We'll begin with just the generic <text:span text:style-name="Literal">SansSerif</text:span> font, but that will change later.
</text:p>
<text:p text:style-name="Code">
PFont font;
</text:p>
<text:p text:style-name="Code">

</text:p>
<text:p text:style-name="Code">
void setup() {
</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
size(480, 750);
</text:p>
<text:p text:style-name="Code">

</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
setupTeams();
</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
setupSalaries();
</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
setupStandings();
</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
setupLogos();
</text:p>
<text:p text:style-name="Code">

</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
font = createFont("SansSerif", 11);
</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
textFont(font);
</text:p>
<text:p text:style-name="Code">
}
</text:p>
<text:p text:style-name="Body_20_Text">
Later, we'll use salary as a tie-breaker when sorting the standings, so <text:span text:style-name="Literal">setupStandings()</text:span> should be after <text:span text:style-name="Literal">setupSalaries()</text:span>. 
</text:p>
<text:p text:style-name="Heading_20_1">Represent</text:p>
<text:p text:style-name="Body_20_Text">
Bringing all this together, we can begin a simple representation to show each row of data with the team name, win-loss record, logo, and salary. We begin with a few <text:span text:style-name="Technical_20_Italic">constants</text:span>, variables prefixed with <text:span text:style-name="Literal">static final</text:span> because they will not change while the sketch is in use. Because the logo height is 22.5 pixels, we'll make each row 23 pixels tall. We'll want to center everything from the middle of the row, so the <text:span text:style-name="Literal">HALF_ROW_HEIGHT</text:span> variable will also come in handy.
</text:p>
<text:p text:style-name="Code">
static final int ROW_HEIGHT = 23;
</text:p>
<text:p text:style-name="Code">
static final float HALF_ROW_HEIGHT = ROW_HEIGHT / 2.0;
</text:p>
<text:p text:style-name="Code">
static final int SIDE_PADDING = 30;
</text:p>
<text:p text:style-name="Body_20_Text">
The text size set earlier is about half the height of each row. This makes easy-to-read double spaced text. The text itself needn't be particularly large or prominent, because it is not as important as the correlation line itself.
</text:p>
<text:p text:style-name="Body_20_Text">
The <text:span text:style-name="Literal">SIDE_PADDING</text:span> variable is used to set a border around the display, adding some white space to the edges. The amount should be more than the row height, so that it looks intentional, but not too large as to waste space.
</text:p>
<text:p text:style-name="Body_20_Text">
The draw method reads as follows:
</text:p>
<text:p text:style-name="Code">
void draw() {
</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
background(255);
</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
smooth();
</text:p>
<text:p text:style-name="Code">

</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
translate(SIDE_PADDING, SIDE_PADDING);
</text:p>
<text:p text:style-name="Code">

</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
float leftX = 160;
</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
float rightX = 335;
</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />

</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
textAlign(LEFT, CENTER);
</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />

</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
for (int i = 0; i &lt; teamCount; i++) {
</text:p>
<text:p text:style-name="Code">
<text:s text:c="4" />
fill(0);
</text:p>
<text:p text:style-name="Code">
<text:s text:c="4" />
float standingsY = standings.getRank(i)*ROW_HEIGHT + HALF_ROW_HEIGHT;
</text:p>
<text:p text:style-name="Code">
<text:s text:c="4" />
image(logos[i], 0, standingsY - logoHeight/2, logoWidth, logoHeight);
</text:p>
<text:p text:style-name="Code">
<text:s text:c="4" />
text(teamNames[i], 28, standingsY);
</text:p>
<text:p text:style-name="Code">
<text:s text:c="4" />
text(standings.getTitle(i), 115, standingsY);
</text:p>
<text:p text:style-name="Code">

</text:p>
<text:p text:style-name="Code">
<text:s text:c="4" />
float salaryY = salaries.getRank(i)*ROW_HEIGHT + HALF_ROW_HEIGHT;
</text:p>
<text:p text:style-name="Code">

</text:p>
<text:p text:style-name="Code">
<text:s text:c="4" />
stroke(0);
</text:p>
<text:p text:style-name="Code">
<text:s text:c="4" />
line(leftX, standingsY, rightX, salaryY);
</text:p>
<text:p text:style-name="Code">

</text:p>
<text:p text:style-name="Code">
<text:s text:c="4" />
text(salaries.getTitle(i), rightX+10, salaryY);
</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
}
</text:p>
<text:p text:style-name="Code">
}
</text:p>
<text:p text:style-name="Body_20_Text">
The <text:span text:style-name="Literal">translate()</text:span> method moves the coordinate system over slightly, giving us a white border: (0, 0) will now be (30, 30), so nothing will be drawn in the left and right 30 pixels of the image.
</text:p>
<text:p text:style-name="Body_20_Text">
The <text:span text:style-name="Literal">leftX</text:span> and <text:span text:style-name="Literal">rightX</text:span> values could also be constants (i.e. <text:span text:style-name="Literal">static final int LEFT_X = 160;</text:span>), but we'll leave them as variables in case we later want to dynamically figure out the position of each column. A better idea than the current implementation (where the X-coordinates were determined by trial and error) would be to base the positions on the maximum width of each column of text plus a little extra padding.
</text:p>
<text:p text:style-name="Body_20_Text">
The <text:span text:style-name="Literal">textAlign()</text:span> method is used to left-align, and vertically center the each row of text.
</text:p>
<text:p text:style-name="Body_20_Text">
A loop travels iterates through each team index (represented by <text:span text:style-name="Literal">i</text:span>). The <text:span text:style-name="Literal">text()</text:span> method draws the team name, aligned to the left, and then the standings value (i.e. 40-29) centered next to it. 
</text:p>
<text:p text:style-name="Body_20_Text">
The <text:span text:style-name="Literal">standingsY</text:span> and <text:span text:style-name="Literal">salaryY</text:span> variables are calculated by the rank of the given team, multiplied by the row height, plus <text:span text:style-name="Literal">HALF_ROW_HEIGHT</text:span> so that the line shows up in the center.
</text:p>
<text:p text:style-name="Body_20_Text">
The resulting image looks like this:
</text:p>
<text:p text:style-name="Body_20_Text">
Figure 04
</text:p>
<text:p text:style-name="Heading_20_1">Refine</text:p>
<text:p text:style-name="Body_20_Text">
When reaching the refinement stage, always return to the original question. We're most concerned with how salaries relate to performance for each team. In the current image, the team logos are the most prominent visual elements (because they're color), while the lines (the most important feature) are about as informative as a pile of sticks. 
</text:p>
<text:p text:style-name="Body_20_Text">
Improving the lines
</text:p>
<text:p text:style-name="Body_20_Text">
The first metric for the original question is whether teams are spending their money well. At its most basic, this is a yes or no question, so it will be important to highlight it as such with the representation. Teams spending their money well have a line that gets lower as it moves from left to right (connecting a high ranking in the standings to a low salary), whereas teams wasting money have lines that move upwards from left to right. By using a color for each scenario, we can highlight the answer to the boolean question of how well the team is performing. Color is a good choice in this case because we only need a pair of colors, and the detail being shown with the color is more important than any other feature in the diagram. To apply the colors, replace the <text:span text:style-name="Literal">stroke(0)</text:span> line with:
</text:p>
<text:p text:style-name="Code">
<text:s text:c="4" />
if (salaryY &gt;= standingsY) {
</text:p>
<text:p text:style-name="Code">
<text:s text:c="6" />
stroke(33, 85, 156);  // Blue for positive (or equal) difference.
</text:p>
<text:p text:style-name="Code">
<text:s text:c="4" />
} else {
</text:p>
<text:p text:style-name="Code">
<text:s text:c="6" />
stroke(206, 0, 82);   // Red for wasting money.
</text:p>
<text:p text:style-name="Code">
<text:s text:c="4" />
}
</text:p>
<text:p text:style-name="Body_20_Text">
Figure 05
</text:p>
<text:p text:style-name="Body_20_Text">
But even with colors, the lines still are not very clear because their thicknesses don't vary enough. Variation is an important queue used by our brains to help us differentiate between elements and determine what shapes are related to one another.
</text:p>
<text:p text:style-name="Body_20_Text">
To introduce more variation into the lines, we can vary the stroke weight based on the team's salary. We could do the same thing with the record, but payroll is more intuitive, as it refers to "bigger" or "smaller" teams—we don't think of standings as big or small, but we do think about monetary amounts in these terms.
</text:p>
<text:p text:style-name="Body_20_Text">
The variation is handled with the <text:span text:style-name="Literal">map()</text:span> method, mapping the minimum salary to a very thin stroke (0.25) and the largest salary to a nice, thick line. Add this code before the <text:span text:style-name="Literal">line()</text:span> statement to scale the line weights in proportion to each team's salary:
</text:p>
<text:p text:style-name="Code">
<text:s text:c="4" />
float weight = map(salaries.getValue(i),
</text:p>
<text:p text:style-name="Code">
<text:s text:c="23" />
salaries.getMinValue(), salaries.getMaxValue(),
</text:p>
<text:p text:style-name="Code">
<text:s text:c="23" />
0.25, 6);
</text:p>
<text:p text:style-name="Code">
<text:s text:c="4" />
strokeWeight(weight);
</text:p>
<text:p text:style-name="Body_20_Text">
Figure 06
</text:p>
<text:p text:style-name="Body_20_Text">
The image is getting more readable than the original in Figure 4, but still more can be done.
</text:p>
<text:p text:style-name="Body_20_Text">
A better typeface
</text:p>
<text:p text:style-name="Body_20_Text">
Instead of the generic SansSerif font, a better option is Matthew Carter's Georgia. The size is also upped a notch to match the amount of space used by the original font:
</text:p>
<text:p text:style-name="Code">
font = createFont("Georgia", 12);
</text:p>
<text:p text:style-name="Body_20_Text">
Carter designed the typeface for Microsoft in 1993 as part of their Web core fonts initiative, as Microsoft's typography group sought better screen fonts that could differentiate Windows and other Microsoft products from their competitors. The Web core fonts package was available as a free download, and is a default font on Windows systems, and installed along with Microsoft software (such as Office) on Mac OS X. This makes it reasonably safe to expect the font to be installed on other machines, rather than using the Create Font Tool. On Linux, the fonts are available from a SourceForge project that repackages the fonts for easy installation. This package is also available as part of some Linux distributions.
</text:p>
<text:p text:style-name="Text_20_body_20_indent">
<text:span text:style-name="Hyperlink">
http://sourceforge.net/projects/corefonts/
</text:span>
</text:p>
<text:p text:style-name="Text_20_body_20_indent">
<text:span text:style-name="Hyperlink">
http://sourceforge.net/project/showfiles.php?group_id=34153
</text:span>
</text:p>
<text:p text:style-name="Body_20_Text">
The font is a good option because it has elegant <text:span text:style-name="Technical_20_Italic">non-lining</text:span> numerals, which will make the number-rich display a little more appealing. Also called <text:span text:style-name="Technical_20_Italic">old style figures</text:span>, the digits will above and below the baseline. The disadvantage in this case is that the numbers won't be identical widths, making them more difficult to compare against one another. Usually this is one helpful indicator when dealing with type—right aligning a series of numbers makes their magnitude obvious at a quick glance. In this piece, however, the exact numbers (whether the Yankees are being paid $189,639,045 or $189,638,042 is not an important distinction) are less important because the numbers are already shown in rank order (the most important axis), so we can sacrifice a little bit of the readability.
</text:p>
<text:p text:style-name="Body_20_Text">
The text still carries too much visual weight, so it needs to be faded a bit. Replacing the <text:span text:style-name="Literal">fill(0)</text:span> statement with <text:span text:style-name="Literal">fill(128)</text:span> will make the text gray, and helps balance the text with the colored lines, appropriately returning the greatest visual importance to the lines themselves.
</text:p>
<text:p text:style-name="Body_20_Text">
Taken together, the new version of the <text:span text:style-name="Literal">draw()</text:span> method follows, with altered portions marked in bold.
</text:p>
<text:p text:style-name="Code">
void draw() {
</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
background(255);
</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
smooth();
</text:p>
<text:p text:style-name="Code">

</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
translate(SIDE_PADDING, SIDE_PADDING);
</text:p>
<text:p text:style-name="Code">

</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
float leftX = 160;
</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
float rightX = 335;
</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />

</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
for (int i = 0; i &lt; teamCount; i++) {
</text:p>
<text:p text:style-name="CodeEmphasis">
<text:s text:c="4" />
fill(128);
</text:p>
<text:p text:style-name="Code">
<text:s text:c="4" />
float standingsY = standings.getRank(i)*ROW_HEIGHT + HALF_ROW_HEIGHT;
</text:p>
<text:p text:style-name="Code">
<text:s text:c="4" />
image(logos[i], 0, standingsY - logoHeight/2, logoWidth, logoHeight);
</text:p>
<text:p text:style-name="CodeEmphasis">
<text:s text:c="4" />
textAlign(LEFT, CENTER);
</text:p>
<text:p text:style-name="Code">
<text:s text:c="4" />
text(teamNames[i], 28, standingsY);
</text:p>
<text:p text:style-name="CodeEmphasis">
<text:s text:c="4" />
textAlign(RIGHT, CENTER);
</text:p>
<text:p text:style-name="CodeEmphasis">
<text:s text:c="4" />
text(standings.getTitle(i), leftX-10, standingsY);
</text:p>
<text:p text:style-name="Code">

</text:p>
<text:p text:style-name="Code">
<text:s text:c="4" />
float salaryY = salaries.getRank(i)*ROW_HEIGHT + HALF_ROW_HEIGHT;
</text:p>
<text:p text:style-name="CodeEmphasis">
<text:s text:c="4" />
if (salaryY &gt;= standingsY) {
</text:p>
<text:p text:style-name="CodeEmphasis">
<text:s text:c="6" />
stroke(33, 85, 156);  // Blue for positive (or equal) difference.
</text:p>
<text:p text:style-name="CodeEmphasis">
<text:s text:c="4" />
} else {
</text:p>
<text:p text:style-name="CodeEmphasis">
<text:s text:c="6" />
stroke(206, 0, 82);   // Red for wasting money.
</text:p>
<text:p text:style-name="CodeEmphasis">
<text:s text:c="4" />
}
</text:p>
<text:p text:style-name="CodeEmphasis">
<text:s text:c="4" />
float weight = map(salaries.getValue(i),
</text:p>
<text:p text:style-name="CodeEmphasis">
<text:s text:c="23" />
salaries.getMinValue(), salaries.getMaxValue(),
</text:p>
<text:p text:style-name="CodeEmphasis">
<text:s text:c="23" />
0.25, 6);
</text:p>
<text:p text:style-name="CodeEmphasis">
<text:s text:c="4" />
strokeWeight(weight);
</text:p>
<text:p text:style-name="Code">
<text:s text:c="3" />

</text:p>
<text:p text:style-name="Code">
<text:s text:c="4" />
line(leftX, standingsY, rightX, salaryY);
</text:p>
<text:p text:style-name="Code">

</text:p>
<text:p text:style-name="CodeEmphasis">
<text:s text:c="4" />
fill(128);
</text:p>
<text:p text:style-name="CodeEmphasis">
<text:s text:c="4" />
textAlign(LEFT, CENTER);
</text:p>
<text:p text:style-name="Code">
<text:s text:c="4" />
text(salaries.getTitle(i), rightX+10, salaryY);
</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
}
</text:p>
<text:p text:style-name="Code">
}
</text:p>
<text:p text:style-name="Body_20_Text">
Figure 07
</text:p>
<text:p text:style-name="Body_20_Text">
A word about dashes and numbers
</text:p>
<text:p text:style-name="Body_20_Text">
The dash used between the win-loss record looks a little wimpy because dashes are so small. A better solution is to use the <text:span text:style-name="Technical_20_Italic">en dash</text:span> character by changing this line from the <text:span text:style-name="Literal">StandingsList</text:span> constructor:
</text:p>
<text:p text:style-name="Code">
<text:s text:c="6" />
title[index] = wins + "-" + losses;
</text:p>
<text:p text:style-name="Body_20_Text">
to read as follows:
</text:p>
<text:p text:style-name="Code">
<text:s text:c="6" />
title[index] = wins + "\u2013" + losses;
</text:p>
<text:p text:style-name="Body_20_Text">
Robert Bringhurst's <text:span text:style-name="Technical_20_Italic">The Elements of Typographical Style</text:span> defines the en dash a suitable for use when separating values that can be broken with the word "to." In this case, the 40-21 next to the Red Sox can be stated as "the Red Sox have a record of 40 to 21," making the en dash suitable for this situation. More about the Bringhurst text can be found in the Refine chapter. 
</text:p>
<text:p text:style-name="Body_20_Text">
The en dash is specified by <text:span text:style-name="Literal">"\u2013"</text:span>, which is a Unicode escape sequence. A Unicode escape is a <text:span text:style-name="Literal">\u</text:span> followed by four hex digits for the character's number in the Unicode character set. More about Unicode can be found in the Parse chapter. Other types of dashes can be used, such as the em dash, <text:span text:style-name="Literal">"\u2012"</text:span>, or the minus sign, <text:span text:style-name="Literal">"\u2212"</text:span>. Using the en dash also has the benefit of ensuring that the vertical position of the dash will align nicely with the horizontal bars of the numbers that it separates.
</text:p>
<text:p text:style-name="Body_20_Text">
Using salary as a tie-breaker
</text:p>
<text:p text:style-name="Body_20_Text">
Another alteration to the <text:span text:style-name="Literal">StandingsList</text:span> is to improve how ties are handled. When two teams have an identical record (not an uncommon occurrence, especially early in the season), the tie should go to the team with the lower salary.
</text:p>
<text:p text:style-name="Body_20_Text">
Inside <text:span text:style-name="Literal">RankedList</text:span>, sorting is handled based on a function that compares two elements in the list. This is common for most sorting algorithms, where a comparison function is made to return zero if the items are identical, and a negative or positive number to indicate whether one value is greater or less than the second value specified. 
</text:p>
<text:p text:style-name="Body_20_Text">
Writing a new <text:span text:style-name="Literal">compare()</text:span> method lets us specify a more sophisticated sort. In the modified method, the <text:span text:style-name="Literal">compare()</text:span> method of the superclass (<text:span text:style-name="Literal">RankedList</text:span>) is called first. If the comparison is a value besides zero, then that means the items are not identical, and the original value can be used. But if the values are identical, the comparison function from the <text:span text:style-name="Literal">salaries</text:span> object is used. Because values for <text:span text:style-name="Literal">a</text:span> and <text:span text:style-name="Literal">b</text:span> refer to the same team in both the standings and salaries (they were ordered using the <text:span text:style-name="Literal">teamIndex()</text:span> function as they were loaded), the comparison works.
</text:p>
<text:p text:style-name="Code">
class StandingsList extends RankedList {
</text:p>
<text:p text:style-name="Code">
<text:s text:c="4" />

</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
StandingsList(String[] lines) {
</text:p>
<text:p text:style-name="Code">
<text:s text:c="4" />
super(teamCount, false);
</text:p>
<text:p text:style-name="Code">
<text:s text:c="6" />

</text:p>
<text:p text:style-name="Code">
<text:s text:c="4" />
for (int i = 0; i &lt; teamCount; i++) {
</text:p>
<text:p text:style-name="Code">
<text:s text:c="6" />
String[] pieces = split(lines[i], TAB);
</text:p>
<text:p text:style-name="Code">
<text:s text:c="6" />
int index = teamIndex(pieces[0]);
</text:p>
<text:p text:style-name="Code">
<text:s text:c="6" />
int wins = parseInt(pieces[1]);
</text:p>
<text:p text:style-name="Code">
<text:s text:c="6" />
int losses = parseInt(pieces[2]);
</text:p>
<text:p text:style-name="Code">
<text:s text:c="8" />

</text:p>
<text:p text:style-name="Code">
<text:s text:c="6" />
value[index] = (float) wins / (float) (wins+losses);
</text:p>
<text:p text:style-name="CodeEmphasis">
<text:s text:c="6" />
title[index] = wins + "\u2013" + losses;
</text:p>
<text:p text:style-name="Code">
<text:s text:c="4" />
}
</text:p>
<text:p text:style-name="Code">
<text:s text:c="4" />
update();
</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
}
</text:p>
<text:p text:style-name="Code">

</text:p>
<text:p text:style-name="CodeEmphasis">
<text:s text:c="2" />
float compare(int a, int b) {
</text:p>
<text:p text:style-name="CodeEmphasis">
<text:s text:c="4" />
// First compare based on the record of both teams
</text:p>
<text:p text:style-name="CodeEmphasis">
<text:s text:c="4" />
float amt = super.compare(a, b);
</text:p>
<text:p text:style-name="CodeEmphasis">
<text:s text:c="4" />
// If the record is not identical, return the difference
</text:p>
<text:p text:style-name="CodeEmphasis">
<text:s text:c="4" />
if (amt != 0) return amt;
</text:p>
<text:p text:style-name="CodeEmphasis">

</text:p>
<text:p text:style-name="CodeEmphasis">
<text:s text:c="4" />
// If records are equal, use salary as tie-breaker.
</text:p>
<text:p text:style-name="CodeEmphasis">
<text:s text:c="4" />
// In this case, a and b are switched, because a higher
</text:p>
<text:p text:style-name="CodeEmphasis">
<text:s text:c="4" />
// salary is a negative thing, unlike the values above.
</text:p>
<text:p text:style-name="CodeEmphasis">
<text:s text:c="4" />
return salaries.compare(a, b);
</text:p>
<text:p text:style-name="CodeEmphasis">
<text:s text:c="2" />
}
</text:p>
<text:p text:style-name="Code">
}
</text:p>
<text:p text:style-name="Heading_20_1">Moving to multiple days (Interact)</text:p>
<text:p text:style-name="Body_20_Text">
So far we've covered a lot of data parsing and some visual refinement. But the static image is unfulfilling—the season changes from day to day, as teams improve, tank, and go on winning streaks. The code used to parse the information for a particular day can easily be adapted to other days, so long as we have a means for iterating through days of the season, and knowing which days to use.
</text:p>
<text:p text:style-name="Body_20_Text">
Dates and time are trickier than you might think. An initial temptation is to simply make an array of numbers for the days in each month. But what happens in a leap year? Do you use a different version of your code? The Java API contains a <text:span text:style-name="Literal">Date</text:span> object that can convert between a <text:span text:style-name="Literal">long</text:span> value (like an <text:span text:style-name="Literal">int</text:span>, but can store far larger numbers) and a formatted date, which is handy. A companion class, <text:span text:style-name="Literal">SimpleDateFormat</text:span>, can parse a date from a <text:span text:style-name="Literal">String</text:span> object given a template, or convert from a <text:span text:style-name="Literal">Date</text:span> object to a date formatted using the same template.
</text:p>
<text:p text:style-name="Body_20_Text">
The <text:span text:style-name="Literal">long</text:span> value of a date is the number of milliseconds elapsed since that date/time and January 1, 1970 (known as the "Unix epoch" or "POSIX time"). Given a starting value, moving to the next day is a matter of increasing the variable by the number of milliseconds in a day. Doing this in a loop will generate all the days of an entire season.
</text:p>
<text:p text:style-name="Body_20_Text">
The code that follows takes as input a date stamp for the first day of the season (<text:span text:style-name="Literal">firstDateStamp</text:span>) in the format YYYYMMDD, and the same for the final day of the season. Because no data is available past the current day, the maximum date for which information can be downloaded is today. However, results for the current day will always be incomplete, so it's best to only get results up to the previous day, this will be encapsulated in <text:span text:style-name="Literal">maxDateIndex</text:span>.
</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
String firstDateStamp = "20070401";
</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
String lastDateStamp = "20070930";
</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
String todayDateStamp;
</text:p>
<text:p text:style-name="Code">

</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
static final long MILLIS_PER_DAY = 24 * 60 * 60 * 1000;
</text:p>
<text:p text:style-name="Code">

</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
// The number of days in the entire season.
</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
int dateCount;
</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
// The current date being shown.
</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
int dateIndex;
</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
// Don't show the first 10 days, they're too erratic.
</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
int minDateIndex = 10;
</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
// The last day of the season, or yesterday, if the season is ongoing.
</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
// This is the maximum date that can be viewed.
</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
int maxDateIndex;
</text:p>
<text:p text:style-name="Code">

</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
// This format makes "20070704" from the date July 4, 2007.
</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
DateFormat stampFormat = new SimpleDateFormat("yyyyMMdd");
</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
// This format makes "4 July 2007" from the same.
</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
DateFormat prettyFormat = new SimpleDateFormat("d MMMM yyyy");
</text:p>
<text:p text:style-name="Code">

</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
// All dates for the season formatted with stampFormat.
</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
String[] dateStamp;
</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
// All dates in the season formatted with prettyFormat.
</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
String[] datePretty;
</text:p>
<text:p text:style-name="Code">

</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
void setupDates() {
</text:p>
<text:p text:style-name="Code">
<text:s text:c="4" />
try {
</text:p>
<text:p text:style-name="Code">
<text:s text:c="6" />
Date firstDate = stampFormat.parse(firstDateStamp);
</text:p>
<text:p text:style-name="Code">
<text:s text:c="6" />
long firstDateMillis = firstDate.getTime();
</text:p>
<text:p text:style-name="Code">
<text:s text:c="6" />
Date lastDate = stampFormat.parse(lastDateStamp);
</text:p>
<text:p text:style-name="Code">
<text:s text:c="6" />
long lastDateMillis = lastDate.getTime();
</text:p>
<text:p text:style-name="Code">

</text:p>
<text:p text:style-name="Code">
<text:s text:c="6" />
// Calculate number of days by dividing the total milliseconds
</text:p>
<text:p text:style-name="Code">
<text:s text:c="6" />
// between the first and last dates by the number of milliseconds per day
</text:p>
<text:p text:style-name="Code">
<text:s text:c="6" />
dateCount = (int)
</text:p>
<text:p text:style-name="Code">
<text:s text:c="8" />
((lastDateMillis - firstDateMillis) / MILLIS_PER_DAY) + 1;
</text:p>
<text:p text:style-name="Code">
<text:s text:c="6" />
maxDateIndex = dateCount;
</text:p>
<text:p text:style-name="Code">
<text:s text:c="6" />
dateStamp = new String[dateCount];
</text:p>
<text:p text:style-name="Code">
<text:s text:c="6" />
datePretty = new String[dateCount];
</text:p>
<text:p text:style-name="Code">

</text:p>
<text:p text:style-name="Code">
<text:s text:c="6" />
todayDateStamp = year() + nf(month(), 2) + nf(day(), 2);
</text:p>
<text:p text:style-name="Code">
<text:s text:c="6" />
// Another option to do this, but more code
</text:p>
<text:p text:style-name="Code">
<text:s text:c="6" />
//Date today = new Date();
</text:p>
<text:p text:style-name="Code">
<text:s text:c="6" />
//String todayDateStamp = stampFormat.format(today);
</text:p>
<text:p text:style-name="Code">
<text:s text:c="6" />

</text:p>
<text:p text:style-name="Code">
<text:s text:c="6" />
for (int i = 0; i &lt; dateCount; i++) {
</text:p>
<text:p text:style-name="Code">
<text:s text:c="8" />
Date date = new Date(firstDateMillis + MILLIS_PER_DAY*i);
</text:p>
<text:p text:style-name="Code">
<text:s text:c="8" />
datePretty[i] = prettyFormat.format(date);
</text:p>
<text:p text:style-name="Code">
<text:s text:c="8" />
dateStamp[i] = stampFormat.format(date);
</text:p>
<text:p text:style-name="Code">
<text:s text:c="8" />
// If this value for 'date' is equal to today, then set the previous
</text:p>
<text:p text:style-name="Code">
<text:s text:c="8" />
// day as the maximum viewable date, because it means the season is
</text:p>
<text:p text:style-name="Code">
<text:s text:c="8" />
// still ongoing. The previous day is used because unless it is late
</text:p>
<text:p text:style-name="Code">
<text:s text:c="8" />
// in the evening, the updated numbers for the day will be unavailable
</text:p>
<text:p text:style-name="Code">
<text:s text:c="8" />
// or incomplete.
</text:p>
<text:p text:style-name="Code">
<text:s text:c="8" />
if (dateStamp[i].equals(todayDateStamp)) {
</text:p>
<text:p text:style-name="Code">
<text:s text:c="10" />
maxDateIndex = i-1;
</text:p>
<text:p text:style-name="Code">
<text:s text:c="8" />
}
</text:p>
<text:p text:style-name="Code">
<text:s text:c="6" />
}
</text:p>
<text:p text:style-name="Code">
<text:s text:c="4" />
} catch (ParseException e) {
</text:p>
<text:p text:style-name="Code">
<text:s text:c="6" />
die("Problem while setting up dates", e);
</text:p>
<text:p text:style-name="Code">
<text:s text:c="4" />
}
</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
}
</text:p>
<text:p text:style-name="Body_20_Text">
The primary result of this function is to set up <text:span text:style-name="Literal">minDateIndex</text:span> and <text:span text:style-name="Literal">maxDateIndex</text:span>, as well as to calculate all dates in the entire season in two formats (the <text:span text:style-name="Literal">dateStamp</text:span> and <text:span text:style-name="Literal">datePretty</text:span> arrays) so that they can be used elsewhere.
</text:p>
<text:p text:style-name="Body_20_Text">
The code above is designed to be more general than the previously mentioned array that holds the number of days in each month. The original version of the project used the simpler method, since hand-tweaking was not a problem and a quick fix (February isn't part of the baseball season either, meaning that no leap year considerations have to be made). But if you were to adapt this project to another situation, such as the football season which spans from Fall to Winter (meaning that the months count 10, 11, 12, then 1) it was more prudent to show here a generic alternative that could be more easily adapted.
</text:p>
<text:p text:style-name="Body_20_Text">
If running this code online, the <text:span text:style-name="Literal">firstDateStamp</text:span> and <text:span text:style-name="Literal">lastDateStamp</text:span> could even be pulled from an HTML parameter using the built-in <text:span text:style-name="Literal">param()</text:span> method, which can read HTML tags for such parameters. This way, different years could be shown without needing to recompile the applet.
</text:p>
<text:p text:style-name="Body_20_Text">
Drawing the dates
</text:p>
<text:p text:style-name="Body_20_Text">
At the top of the screen we'll add a simple date selector. The selector will consist of a series of vertical lines, with the current date shown as a longer line, and the title of the date (taken from <text:span text:style-name="Literal">datePretty</text:span>) shown beneath it.
</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
int dateSelectorX;
</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
int dateSelectorY = 30;
</text:p>
<text:p text:style-name="Code">

</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
// Draw a series of lines for selecting the date
</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
void drawDateSelector() {
</text:p>
<text:p text:style-name="Code">
<text:s text:c="4" />
dateSelectorX = (width - dateCount*2) / 2;
</text:p>
<text:p text:style-name="Code">

</text:p>
<text:p text:style-name="Code">
<text:s text:c="4" />
strokeWeight(1);
</text:p>
<text:p text:style-name="Code">
<text:s text:c="4" />
for (int i = 0; i &lt; dateCount; i++) {
</text:p>
<text:p text:style-name="Code">
<text:s text:c="6" />
int x = dateSelectorX + i*2;
</text:p>
<text:p text:style-name="Code">

</text:p>
<text:p text:style-name="Code">
<text:s text:c="6" />
// If this is the currently selected date, draw it differently
</text:p>
<text:p text:style-name="Code">
<text:s text:c="6" />
if (i == dateIndex) {
</text:p>
<text:p text:style-name="Code">
<text:s text:c="8" />
stroke(0);
</text:p>
<text:p text:style-name="Code">
<text:s text:c="8" />
line(x, 0, x, 13);
</text:p>
<text:p text:style-name="Code">
<text:s text:c="8" />
textAlign(CENTER, TOP);
</text:p>
<text:p text:style-name="Code">
<text:s text:c="8" />
text(datePretty[dateIndex], x, 15);
</text:p>
<text:p text:style-name="Code">

</text:p>
<text:p text:style-name="Code">
<text:s text:c="6" />
} else {
</text:p>
<text:p text:style-name="Code">
<text:s text:c="8" />
// If this is a viewable date, make the line darker
</text:p>
<text:p text:style-name="Code">
<text:s text:c="8" />
if ((i &gt;= minDateIndex) &amp;&amp; (i &lt;= maxDateIndex)) {
</text:p>
<text:p text:style-name="Code">
<text:s text:c="10" />
stroke(128);  // Viewable date
</text:p>
<text:p text:style-name="Code">
<text:s text:c="8" />
} else {
</text:p>
<text:p text:style-name="Code">
<text:s text:c="10" />
stroke(204);  // Not a viewable date
</text:p>
<text:p text:style-name="Code">
<text:s text:c="8" />
}
</text:p>
<text:p text:style-name="Code">
<text:s text:c="8" />
line(x, 0, x, 7);
</text:p>
<text:p text:style-name="Code">
<text:s text:c="6" />
}
</text:p>
<text:p text:style-name="Code">
<text:s text:c="4" />
}
</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
}
</text:p>
<text:p text:style-name="Body_20_Text">
Load standings for the entire season
</text:p>
<text:p text:style-name="Body_20_Text">
An update to the <text:span text:style-name="Literal">setupStandings()</text:span> function downloads data for each day of the season (if it has not yet been downloaded), and the <text:span text:style-name="Literal">season</text:span> array stores each day of standings for the season thus far. 
</text:p>
<text:p text:style-name="Code">
StandingsList[] season;
</text:p>
<text:p text:style-name="Code">

</text:p>
<text:p text:style-name="Code">
void setupStandings() {
</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
season = new StandingsList[maxDateIndex + 1];
</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
for (int i = minDateIndex; i &lt;= maxDateIndex; i++) {
</text:p>
<text:p text:style-name="Code">
<text:s text:c="4" />
String[] lines = acquireStandings(dateStamp[i]);
</text:p>
<text:p text:style-name="Code">
<text:s text:c="4" />
season[i] = new StandingsList(lines);
</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
}
</text:p>
<text:p text:style-name="Code">
}
</text:p>
<text:p text:style-name="Body_20_Text">
Another version of the <text:span text:style-name="Literal">acquireStandings()</text:span> method also breaks up a date stamp into its component parts so that it can be handled by the original <text:span text:style-name="Literal">acquireStandings</text:span> method:
</text:p>
<text:p text:style-name="Code">
String[] acquireStandings(String stamp) {
</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
int year = int(stamp.substring(0, 4));
</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
int month = int(stamp.substring(4, 6));
</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
int day = int(stamp.substring(6, 8));
</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
return acquireStandings(year, month, day);
</text:p>
<text:p text:style-name="Code">
}
</text:p>
<text:p text:style-name="Body_20_Text">
Switching between dates
</text:p>
<text:p text:style-name="Body_20_Text">
With all the data in place, selecting dates is a matter of determining where the mouse was clicked inside the date selector area. The <text:span text:style-name="Literal">mousePressed()</text:span> and <text:span text:style-name="Literal">mouseDragged()</text:span> will be combined to a single <text:span text:style-name="Literal">handleMouse()</text:span> method that calculates whether a new date was chosen:
</text:p>
<text:p text:style-name="Code">
void setDate(int index) {
</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
dateIndex = index;
</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
standings = season[dateIndex];
</text:p>
<text:p text:style-name="Code">
}
</text:p>
<text:p text:style-name="Code">

</text:p>
<text:p text:style-name="Code">
void mousePressed() {
</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
handleMouse();
</text:p>
<text:p text:style-name="Code">
}
</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />

</text:p>
<text:p text:style-name="Code">
void mouseDragged() {
</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
handleMouse();
</text:p>
<text:p text:style-name="Code">
}
</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />

</text:p>
<text:p text:style-name="Code">
void handleMouse() {
</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
if (mouseY &lt; dateSelectorY) {
</text:p>
<text:p text:style-name="Code">
<text:s text:c="4" />
int date = (mouseX - dateSelectorX) / 2;
</text:p>
<text:p text:style-name="Code">
<text:s text:c="4" />
setDate(constrain(date, minDateIndex, maxDateIndex));
</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
}
</text:p>
<text:p text:style-name="Code">
}
</text:p>
<text:p text:style-name="Body_20_Text">
And just for kicks, we add a <text:span text:style-name="Literal">keyPressed()</text:span> method so that we can use the arrow keys to move back and forth in time:
</text:p>
<text:p text:style-name="Code">
void keyPressed() {
</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
if (key == CODED) {
</text:p>
<text:p text:style-name="Code">
<text:s text:c="4" />
if (keyCode == LEFT) {
</text:p>
<text:p text:style-name="Code">
<text:s text:c="6" />
int newDate = max(dateIndex - 1, minDateIndex);
</text:p>
<text:p text:style-name="Code">
<text:s text:c="6" />
setDate(newDate);
</text:p>
<text:p text:style-name="Code">

</text:p>
<text:p text:style-name="Code">
<text:s text:c="4" />
} else if (keyCode == RIGHT) {
</text:p>
<text:p text:style-name="Code">
<text:s text:c="6" />
int newDate = min(dateIndex + 1, maxDateIndex);
</text:p>
<text:p text:style-name="Code">
<text:s text:c="6" />
setDate(newDate);
</text:p>
<text:p text:style-name="Code">
<text:s text:c="4" />
}
</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
}
</text:p>
<text:p text:style-name="Code">
}
</text:p>
<text:p text:style-name="Body_20_Text">
Checking our progress
</text:p>
<text:p text:style-name="Body_20_Text">
The only visible progress can be seen in the date selector at the top of the screen:
</text:p>
<text:p text:style-name="Body_20_Text">
Figure 08
</text:p>
<text:p text:style-name="Body_20_Text">
But by clicking and dragging across the date selector, the display will rapidly switch between the standings for each day. The update is too jerky, which makes it difficult to follow. As you might guess, we'll next bring back our Integrator friend to help smooth things out.
</text:p>
<text:p text:style-name="Heading_20_1">Smoothing out the interaction (Refine)</text:p>
<text:p text:style-name="Body_20_Text">
In what is perhaps becoming a common refrain, we'll next be adding the <text:span text:style-name="Literal">Integrator</text:span> class to the sketch, which will help us animate the transition between days:
</text:p>
<text:p text:style-name="Text_20_body_20_indent">
<text:span text:style-name="Hyperlink">
http://benfry.com/book/salaryper/Integrator.java
</text:span>
</text:p>
<text:p text:style-name="Body_20_Text">
The only value that moves are the 30 values for the standings, so we'll add a <text:span text:style-name="Literal">setupRanking()</text:span> function to initialize them and set a default position. Add a call to <text:span text:style-name="Literal">setupRanking()</text:span> inside <text:span text:style-name="Literal">setup()</text:span>, just after the other <text:span text:style-name="Literal">setupXxxxx()</text:span> functions.
</text:p>
<text:p text:style-name="Code">
Integrator[] standingsPosition;
</text:p>
<text:p text:style-name="Code">

</text:p>
<text:p text:style-name="Code">
void setupRanking() {
</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
standingsPosition = new Integrator[teamCount];
</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
for (int i = 0; i &lt; teamCodes.length; i++) {
</text:p>
<text:p text:style-name="Code">
<text:s text:c="4" />
standingsPosition[i] = new Integrator(i);
</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
}
</text:p>
<text:p text:style-name="Code">
}
</text:p>
<text:p text:style-name="Body_20_Text">
Inside <text:span text:style-name="Literal">draw()</text:span>, we'll no longer use <text:span text:style-name="Literal">getRank()</text:span> to determine the location for <text:span text:style-name="Literal">standingsY</text:span>.
</text:p>
<text:p text:style-name="Code">
float standingsY = standings.getRank(i)*ROW_HEIGHT + HALF_ROW_HEIGHT;
</text:p>
<text:p text:style-name="Body_20_Text">
Instead, it will be based on the current position of each <text:span text:style-name="Literal">Integrator</text:span> (that are taking their sweet time to reach the current rankings) rather than the actual ranking value:
</text:p>
<text:p text:style-name="Code">
float standingsY = standingsPosition[i].value * ROW_HEIGHT + HALF_ROW_HEIGHT;
</text:p>
<text:p text:style-name="Body_20_Text">
At the beginning of <text:span text:style-name="Literal">draw()</text:span>, it's also necessary to update each <text:span text:style-name="Literal">standingsPosition</text:span>. As a twist, we'll also keep track of whether any of the <text:span text:style-name="Literal">Integrator</text:span>s actually change inside their <text:span text:style-name="Literal">update()</text:span> method (which returns true if the value actually changed by some amount). If no changes occur, then we'll use <text:span text:style-name="Literal">noLoop()</text:span> shut off the animation loop to save CPU cycles:
</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
boolean updated = false;
</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
for (int i = 0; i &lt; teamCount; i++) {
</text:p>
<text:p text:style-name="Code">
<text:s text:c="4" />
if (standingsPosition[i].update()) {
</text:p>
<text:p text:style-name="Code">
<text:s text:c="6" />
updated = true;
</text:p>
<text:p text:style-name="Code">
<text:s text:c="4" />
}
</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
}
</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
if (!updated) {
</text:p>
<text:p text:style-name="Code">
<text:s text:c="4" />
noLoop();
</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
}
</text:p>
<text:p text:style-name="Body_20_Text">
Of course, we will eventually need to turn the animation back on, when the user selects a new date. An updated <text:span text:style-name="Literal">setDate()</text:span> method will handle targeting the new ranking values with each <text:span text:style-name="Literal">Integrator</text:span>, and starting up the animation loop by calling <text:span text:style-name="Literal">loop()</text:span>.
</text:p>
<text:p text:style-name="Code">
void setDate(int index) {
</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
dateIndex = index;
</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
standings = season[dateIndex];
</text:p>
<text:p text:style-name="Code">

</text:p>
<text:p text:style-name="CodeEmphasis">
<text:s text:c="2" />
for (int i = 0; i &lt; teamCount; i++) {
</text:p>
<text:p text:style-name="CodeEmphasis">
<text:s text:c="4" />
standingsPosition[i].target(standings.getRank(i));
</text:p>
<text:p text:style-name="CodeEmphasis">
<text:s text:c="2" />
}
</text:p>
<text:p text:style-name="CodeEmphasis">
<text:s text:c="2" />
// Re-enable the animation loop
</text:p>
<text:p text:style-name="CodeEmphasis">
<text:s text:c="2" />
loop();
</text:p>
<text:p text:style-name="Code">
}
</text:p>
<text:p text:style-name="Body_20_Text">
Also regarding animation, it's important to also set a frame rate at which the sketch should be run, so that it behaves consistently on other machines. Adding <text:span text:style-name="Literal">frameRate(15)</text:span> to <text:span text:style-name="Literal">setup()</text:span> will ensure that transitions behave smoothly and the animation is consistent even on much faster computers.
</text:p>
<text:p text:style-name="Heading_20_1">Deployment considerations (Acquire, Parse, Filter)</text:p>
<text:p text:style-name="Body_20_Text">
As discussed in the second chapter, sketches that run online inside a web browser are not allowed access to the user's local file system (for security reasons). That means our current scheme of downloading files for each day and using the <text:span text:style-name="Literal">File</text:span> object to check whether they've already been downloaded won't be sufficient. 
</text:p>
<text:p text:style-name="Body_20_Text">
As it turns out, the current implementation is also quite inefficient: at the end of the season you'll have hundreds of individual files on your disk for each day, but each of them occupy about 300 bytes apiece.
</text:p>
<text:p text:style-name="Body_20_Text">
So instead, we return back to the early preprocessing steps. The solution for both situations is to instead run the pre-processing steps from a CGI script. The script can download the data once for each day, then join each of the files into a single one that can be downloaded by a web visitor. If the CGI script runs from the same server as the sketch, the sketch will be able to connect to it and download the data, since connecting back to its parent server is considered safe under Java's security model.
</text:p>
<text:p text:style-name="Body_20_Text">
A Perl version of the script, essentially an adaptation of the <text:span text:style-name="Literal">acquireStandings()</text:span> and <text:span text:style-name="Literal">parseWinLoss()</text:span> methods follows. Creating a version for PHP or other web frameworks shouldn't be too much of a stretch.
</text:p>
<text:p text:style-name="Code">
#!/usr/bin/perl -w
</text:p>
<text:p text:style-name="Code">

</text:p>
<text:p text:style-name="Code">
use Time::Local;
</text:p>
<text:p text:style-name="Code">

</text:p>
<text:p text:style-name="Code">
# Send header to the web server to indicate we are awake,
</text:p>
<text:p text:style-name="Code">
# and that plain text data will be returned.
</text:p>
<text:p text:style-name="Code">
print "Content-type: text/plain\n\n";
</text:p>
<text:p text:style-name="Code">

</text:p>
<text:p text:style-name="Code">
# These values could be read from parameters to the CGI if so desired, i.e.
</text:p>
<text:p text:style-name="Code">
# http://benfry.com/salaryper/data.cgi?first=20070401&last=20070930&min=10
</text:p>
<text:p text:style-name="Code">
# This would make the software more flexible to use it for multiple years.
</text:p>
<text:p text:style-name="Code">
$firstDateStamp = '20070401';
</text:p>
<text:p text:style-name="Code">
$lastDateStamp = '20070930';
</text:p>
<text:p text:style-name="Code">
$minDateIndex = 10;
</text:p>
<text:p text:style-name="Code">

</text:p>
<text:p text:style-name="Code">
$dataFolder = 'individual';
</text:p>
<text:p text:style-name="Code">
$comboFolder = 'combined';
</text:p>
<text:p text:style-name="Code">
`mkdir -p $dataFolder`;
</text:p>
<text:p text:style-name="Code">
`mkdir -p $comboFolder`;
</text:p>
<text:p text:style-name="Code">

</text:p>
<text:p text:style-name="Code">
$firstDateStamp =~ /(\d\d\d\d)(\d\d)(\d\d)/;
</text:p>
<text:p text:style-name="Code">
$year = $1;
</text:p>
<text:p text:style-name="Code">
$month = $2 - 1;  # Months are 0-indexed in Perl
</text:p>
<text:p text:style-name="Code">
$day = $3;
</text:p>
<text:p text:style-name="Code">
$firstDate = timelocal(0, 0, 0, $day, $month, $year);
</text:p>
<text:p text:style-name="Code">

</text:p>
<text:p text:style-name="Code">
$lastDateStamp =~ /(\d\d\d\d)(\d\d)(\d\d)/;
</text:p>
<text:p text:style-name="Code">
$year = $1;
</text:p>
<text:p text:style-name="Code">
$month = $2 - 1;  # Months are 0-indexed in Perl
</text:p>
<text:p text:style-name="Code">
$day = $3;
</text:p>
<text:p text:style-name="Code">
$lastDate = timelocal(0, 0, 0, $day, $month, $year);
</text:p>
<text:p text:style-name="Code">

</text:p>
<text:p text:style-name="Code">
$SECONDS_PER_DAY = 24 * 60 * 60;
</text:p>
<text:p text:style-name="Code">

</text:p>
<text:p text:style-name="Code">
# Yesterday is the maximum possible date,
</text:p>
<text:p text:style-name="Code">
# because the scores from today will not yet be updated.
</text:p>
<text:p text:style-name="Code">
$yesterdayDate = time - $SECONDS_PER_DAY;
</text:p>
<text:p text:style-name="Code">

</text:p>
<text:p text:style-name="Code">
# Don't bother grabbing data for the earlier part of the season
</text:p>
<text:p text:style-name="Code">
# because it will not be used (and the program is not expecting it)
</text:p>
<text:p text:style-name="Code">
$date = $firstDate + $minDateIndex*$SECONDS_PER_DAY;
</text:p>
<text:p text:style-name="Code">

</text:p>
<text:p text:style-name="Code">
my @dateStamps = ();
</text:p>
<text:p text:style-name="Code">

</text:p>
<text:p text:style-name="Code">
# If season is ongoing, only read data through yesterday.
</text:p>
<text:p text:style-name="Code">
$endDate = ($yesterdayDate &lt; $lastDate) ? $yesterdayDate : $lastDate;
</text:p>
<text:p text:style-name="Code">
while ($date &lt;= $endDate) {
</text:p>
<text:p text:style-name="Code">
<text:s text:c="4" />
($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) =
</text:p>
<text:p text:style-name="Code">
<text:s text:c="8" />
localtime($date);
</text:p>
<text:p text:style-name="Code">
<text:s text:c="4" />
$stamp = sprintf("%04d%02d%02d", $year + 1900, $mon+1, $mday);
</text:p>
<text:p text:style-name="Code">
<text:s text:c="4" />
push @dateStamps, $stamp;
</text:p>
<text:p text:style-name="Code">
<text:s text:c="4" />
#print "$date - " . localtime($date) . "\n";
</text:p>
<text:p text:style-name="Code">
<text:s text:c="4" />
$date += $SECONDS_PER_DAY;
</text:p>
<text:p text:style-name="Code">
}
</text:p>
<text:p text:style-name="Code">
$endDateStamp = $dateStamps[$#dateStamps];
</text:p>
<text:p text:style-name="Code">

</text:p>
<text:p text:style-name="Code">
$combinedFile = "$comboFolder/$endDateStamp.tsv";
</text:p>
<text:p text:style-name="Code">
if (-f $combinedFile) {
</text:p>
<text:p text:style-name="Code">
<text:s text:c="4" />
# Open the file and spew the contents back to the applet.
</text:p>
<text:p text:style-name="Code">
<text:s text:c="4" />
open(INPUT, $combinedFile) || die $!;
</text:p>
<text:p text:style-name="Code">
<text:s text:c="4" />
@contents = &lt;INPUT&gt;;
</text:p>
<text:p text:style-name="Code">
<text:s text:c="4" />
print @contents;
</text:p>
<text:p text:style-name="Code">
<text:s text:c="4" />
close(INPUT);
</text:p>
<text:p text:style-name="Code">

</text:p>
<text:p text:style-name="Code">
} else {
</text:p>
<text:p text:style-name="Code">
<text:s text:c="4" />
# Download any days not yet downloaded.
</text:p>
<text:p text:style-name="Code">
<text:s text:c="4" />
foreach $stamp (@dateStamps) {
</text:p>
<text:p text:style-name="Code">
<text:s text:c="8" />
$filename = "$dataFolder/$stamp.tsv";
</text:p>
<text:p text:style-name="Code">
<text:s text:c="8" />
if (!(-f $filename)) {
</text:p>
<text:p text:style-name="Code">
<text:s text:c="12" />
downloadWinLoss($stamp);
</text:p>
<text:p text:style-name="Code">
<text:s text:c="8" />
}
</text:p>
<text:p text:style-name="Code">
<text:s text:c="4" />
}
</text:p>
<text:p text:style-name="Code">
<text:s text:c="4" />
# Concatenate everything into a single file.
</text:p>
<text:p text:style-name="Code">
<text:s text:c="4" />
open(OUTPUT, "&gt;$combinedFile") || die $!;
</text:p>
<text:p text:style-name="Code">
<text:s text:c="4" />
foreach $stamp (@dateStamps) {
</text:p>
<text:p text:style-name="Code">
<text:s text:c="8" />
open(INPUT, "$dataFolder/$stamp.tsv") || die $!;
</text:p>
<text:p text:style-name="Code">
<text:s text:c="8" />
@contents = &lt;INPUT&gt;;
</text:p>
<text:p text:style-name="Code">
<text:s text:c="8" />
print OUTPUT @contents;
</text:p>
<text:p text:style-name="Code">
<text:s text:c="8" />
close(INPUT);
</text:p>
<text:p text:style-name="Code">

</text:p>
<text:p text:style-name="Code">
<text:s text:c="8" />
# Also write the contents of this file to the applet.
</text:p>
<text:p text:style-name="Code">
<text:s text:c="8" />
print @contents;
</text:p>
<text:p text:style-name="Code">
<text:s text:c="4" />
}
</text:p>
<text:p text:style-name="Code">
<text:s text:c="4" />
close(OUTPUT);
</text:p>
<text:p text:style-name="Code">
}
</text:p>
<text:p text:style-name="Code">

</text:p>
<text:p text:style-name="Code">

</text:p>
<text:p text:style-name="Code">
sub downloadWinLoss() {
</text:p>
<text:p text:style-name="Code">
<text:s text:c="4" />
my $stamp = shift;
</text:p>
<text:p text:style-name="Code">
<text:s text:c="4" />

</text:p>
<text:p text:style-name="Code">
<text:s text:c="4" />
open(OUTPUT, "&gt;$dataFolder/$stamp.tsv") || die $!;
</text:p>
<text:p text:style-name="Code">

</text:p>
<text:p text:style-name="Code">
<text:s text:c="4" />
$stamp =~ /(\d\d\d\d)(\d\d)(\d\d)/;
</text:p>
<text:p text:style-name="Code">
<text:s text:c="4" />
$day = sprintf("year_%04d/month_%02d/day_%02d/", $1, $2, $3);
</text:p>
<text:p text:style-name="Code">

</text:p>
<text:p text:style-name="Code">
<text:s text:c="4" />
$base = 'http://mlb.mlb.com/components/game/' . $day;
</text:p>
<text:p text:style-name="Code">

</text:p>
<text:p text:style-name="Code">
<text:s text:c="4" />
parseWinLoss($base . 'standings_rs_ale.js');
</text:p>
<text:p text:style-name="Code">
<text:s text:c="4" />
parseWinLoss($base . 'standings_rs_alw.js');
</text:p>
<text:p text:style-name="Code">
<text:s text:c="4" />
parseWinLoss($base . 'standings_rs_alc.js');
</text:p>
<text:p text:style-name="Code">

</text:p>
<text:p text:style-name="Code">
<text:s text:c="4" />
parseWinLoss($base . 'standings_rs_nle.js');
</text:p>
<text:p text:style-name="Code">
<text:s text:c="4" />
parseWinLoss($base . 'standings_rs_nlw.js');
</text:p>
<text:p text:style-name="Code">
<text:s text:c="4" />
parseWinLoss($base . 'standings_rs_nlc.js');
</text:p>
<text:p text:style-name="Code">

</text:p>
<text:p text:style-name="Code">
<text:s text:c="4" />
close(OUTPUT);
</text:p>
<text:p text:style-name="Code">
}
</text:p>
<text:p text:style-name="Code">

</text:p>
<text:p text:style-name="Code">

</text:p>
<text:p text:style-name="Code">
sub parseWinLoss() {
</text:p>
<text:p text:style-name="Code">
<text:s text:c="4" />
$url = shift;
</text:p>
<text:p text:style-name="Code">
<text:s text:c="4" />
# Download the contents of the .js file using "curl"
</text:p>
<text:p text:style-name="Code">
<text:s text:c="4" />
@lines = `curl --silent $url`;
</text:p>
<text:p text:style-name="Code">

</text:p>
<text:p text:style-name="Code">
<text:s text:c="4" />
$teamCode = '';
</text:p>
<text:p text:style-name="Code">
<text:s text:c="4" />
$wins = 0;
</text:p>
<text:p text:style-name="Code">
<text:s text:c="4" />
$losses = 0;
</text:p>
<text:p text:style-name="Code">

</text:p>
<text:p text:style-name="Code">
<text:s text:c="4" />
foreach $line (@lines) {
</text:p>
<text:p text:style-name="Code">
<text:s text:c="8" />
if ($line =~ /\s+([\w\d]+):\s'(.*)',?/) {
</text:p>
<text:p text:style-name="Code">
<text:s text:c="12" />
$attr = $1;
</text:p>
<text:p text:style-name="Code">
<text:s text:c="12" />
$value = $2;
</text:p>
<text:p text:style-name="Code">
<text:s text:c="12" />
if ($attr eq 'code') {
</text:p>
<text:p text:style-name="Code">
<text:s text:c="16" />
$teamCode = $value;
</text:p>
<text:p text:style-name="Code">
<text:s text:c="12" />
} elsif ($attr eq 'w') {
</text:p>
<text:p text:style-name="Code">
<text:s text:c="16" />
$wins = $value;
</text:p>
<text:p text:style-name="Code">
<text:s text:c="12" />
} elsif ($attr eq 'l') {
</text:p>
<text:p text:style-name="Code">
<text:s text:c="16" />
$losses = $value;
</text:p>
<text:p text:style-name="Code">
<text:s text:c="12" />
}
</text:p>
<text:p text:style-name="Code">

</text:p>
<text:p text:style-name="Code">
<text:s text:c="8" />
} elsif ($line =~ /^}/) {
</text:p>
<text:p text:style-name="Code">
<text:s text:c="12" />
# This is the end of a group, print the values
</text:p>
<text:p text:style-name="Code">
<text:s text:c="12" />
print OUTPUT "$teamCode\t$wins\t$losses\n";
</text:p>
<text:p text:style-name="Code">
<text:s text:c="8" />
}
</text:p>
<text:p text:style-name="Code">
<text:s text:c="4" />
}
</text:p>
<text:p text:style-name="Code">
}
</text:p>
<text:p text:style-name="Body_20_Text">
The script can be seen in action at:
</text:p>
<text:p text:style-name="Text_20_body_20_indent">
<text:span text:style-name="Hyperlink">
http://benfry.com/book/salaryper/mlb.cgi
</text:span>
</text:p>
<text:p text:style-name="Body_20_Text">
Or downloaded directly from:
</text:p>
<text:p text:style-name="Text_20_body_20_indent">
<text:span text:style-name="Hyperlink">
http://benfry.com/book/salaryper/mlb.cgi.txt
</text:span>
</text:p>
<text:p text:style-name="Body_20_Text">
If data has not been downloaded for the current day, it downloads the new information, then produces a file that concatenates all the days found so far. If this has already occurred once, the file itself is simply echoed back to the web server.
</text:p>
<text:p text:style-name="Body_20_Text">
Because this also moves all the preprocessing code out of the sketch, the <text:span text:style-name="Literal">acquireStandings()</text:span> and <text:span text:style-name="Literal">parseWinLoss()</text:span> methods can be removed from the code, simplifying things greatly. The new version of <text:span text:style-name="Literal">setupStandings()</text:span> that reads the data instead uses a URL to download the data, and then creates a new <text:span text:style-name="Literal">StandingsList</text:span> for each set of 30 lines. The <text:span text:style-name="Literal">maxDateIndex</text:span> is determined by the amount of data received from the CGI script, and it's important to keep the <text:span text:style-name="Literal">minDateIndex</text:span> variable in your code in sync with the <text:span text:style-name="Literal">minDateIndex</text:span> value used in the CGI, so that both pieces of software are expected the same day as the first.
</text:p>
<text:p text:style-name="Body_20_Text">
The complete code follows.
</text:p>
<text:p text:style-name="Code">
import java.util.regex.*;
</text:p>
<text:p text:style-name="Code">

</text:p>
<text:p text:style-name="Code">
int teamCount = 30;
</text:p>
<text:p text:style-name="Code">
String[] teamNames;
</text:p>
<text:p text:style-name="Code">
String[] teamCodes;
</text:p>
<text:p text:style-name="Code">
HashMap teamIndices;
</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />

</text:p>
<text:p text:style-name="Code">
static final int ROW_HEIGHT = 23;
</text:p>
<text:p text:style-name="Code">
static final float HALF_ROW_HEIGHT = ROW_HEIGHT / 2.0f;
</text:p>
<text:p text:style-name="Code">

</text:p>
<text:p text:style-name="Code">
static final int SIDE_PADDING = 30;
</text:p>
<text:p text:style-name="Code">
static final int TOP_PADDING = 40;
</text:p>
<text:p text:style-name="Code">

</text:p>
<text:p text:style-name="Code">
SalaryList salaries;
</text:p>
<text:p text:style-name="Code">
StandingsList standings;
</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />

</text:p>
<text:p text:style-name="Code">
StandingsList[] season;
</text:p>
<text:p text:style-name="Code">
Integrator[] standingsPosition;
</text:p>
<text:p text:style-name="Code">

</text:p>
<text:p text:style-name="Code">
PImage[] logos;
</text:p>
<text:p text:style-name="Code">
float logoWidth;
</text:p>
<text:p text:style-name="Code">
float logoHeight;
</text:p>
<text:p text:style-name="Code">

</text:p>
<text:p text:style-name="Code">
PFont font;
</text:p>
<text:p text:style-name="Code">

</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />

</text:p>
<text:p text:style-name="Code">
// . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />

</text:p>
<text:p text:style-name="Code">

</text:p>
<text:p text:style-name="Code">
String firstDateStamp = "20070401";
</text:p>
<text:p text:style-name="Code">
String lastDateStamp = "20070930";
</text:p>
<text:p text:style-name="Code">
String todayDateStamp;
</text:p>
<text:p text:style-name="Code">

</text:p>
<text:p text:style-name="Code">
static final long MILLIS_PER_DAY = 24 * 60 * 60 * 1000;
</text:p>
<text:p text:style-name="Code">

</text:p>
<text:p text:style-name="Code">
// The number of days in the entire season.
</text:p>
<text:p text:style-name="Code">
int dateCount;
</text:p>
<text:p text:style-name="Code">
// The current date being shown.
</text:p>
<text:p text:style-name="Code">
int dateIndex;
</text:p>
<text:p text:style-name="Code">
// Don't show the first 10 days, they're too erratic.
</text:p>
<text:p text:style-name="Code">
int minDateIndex = 10;
</text:p>
<text:p text:style-name="Code">
// The last day of the season, or yesterday, if the season is ongoing.
</text:p>
<text:p text:style-name="Code">
// This is the maximum date that can be viewed.
</text:p>
<text:p text:style-name="Code">
int maxDateIndex;
</text:p>
<text:p text:style-name="Code">

</text:p>
<text:p text:style-name="Code">
// This format makes "20070704" from the date July 4, 2007.
</text:p>
<text:p text:style-name="Code">
DateFormat stampFormat = new SimpleDateFormat("yyyyMMdd");
</text:p>
<text:p text:style-name="Code">
// This format makes "4 July 2007" from the same.
</text:p>
<text:p text:style-name="Code">
DateFormat prettyFormat = new SimpleDateFormat("d MMMM yyyy");
</text:p>
<text:p text:style-name="Code">

</text:p>
<text:p text:style-name="Code">
// All dates for the season formatted with stampFormat.
</text:p>
<text:p text:style-name="Code">
String[] dateStamp;
</text:p>
<text:p text:style-name="Code">
// All dates in the season formatted with prettyFormat.
</text:p>
<text:p text:style-name="Code">
String[] datePretty;
</text:p>
<text:p text:style-name="Code">

</text:p>
<text:p text:style-name="Code">
void setupDates() {
</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
try {
</text:p>
<text:p text:style-name="Code">
<text:s text:c="4" />
Date firstDate = stampFormat.parse(firstDateStamp);
</text:p>
<text:p text:style-name="Code">
<text:s text:c="4" />
long firstDateMillis = firstDate.getTime();
</text:p>
<text:p text:style-name="Code">
<text:s text:c="4" />
Date lastDate = stampFormat.parse(lastDateStamp);
</text:p>
<text:p text:style-name="Code">
<text:s text:c="4" />
long lastDateMillis = lastDate.getTime();
</text:p>
<text:p text:style-name="Code">

</text:p>
<text:p text:style-name="Code">
<text:s text:c="4" />
// Calculate number of days by dividing the total milliseconds
</text:p>
<text:p text:style-name="Code">
<text:s text:c="4" />
// between the first and last dates by the number of milliseconds per day
</text:p>
<text:p text:style-name="Code">
<text:s text:c="4" />
dateCount = (int)
</text:p>
<text:p text:style-name="Code">
<text:s text:c="6" />
((lastDateMillis - firstDateMillis) / MILLIS_PER_DAY) + 1;
</text:p>
<text:p text:style-name="Code">
<text:s text:c="4" />
maxDateIndex = dateCount;
</text:p>
<text:p text:style-name="Code">
<text:s text:c="4" />
dateStamp = new String[dateCount];
</text:p>
<text:p text:style-name="Code">
<text:s text:c="4" />
datePretty = new String[dateCount];
</text:p>
<text:p text:style-name="Code">

</text:p>
<text:p text:style-name="Code">
<text:s text:c="4" />
todayDateStamp = year() + nf(month(), 2) + nf(day(), 2);
</text:p>
<text:p text:style-name="Code">
<text:s text:c="4" />
// Another option to do this, but more code
</text:p>
<text:p text:style-name="Code">
<text:s text:c="4" />
//Date today = new Date();
</text:p>
<text:p text:style-name="Code">
<text:s text:c="4" />
//String todayDateStamp = stampFormat.format(today);
</text:p>
<text:p text:style-name="Code">
<text:s text:c="6" />

</text:p>
<text:p text:style-name="Code">
<text:s text:c="4" />
for (int i = 0; i &lt; dateCount; i++) {
</text:p>
<text:p text:style-name="Code">
<text:s text:c="6" />
Date date = new Date(firstDateMillis + MILLIS_PER_DAY*i);
</text:p>
<text:p text:style-name="Code">
<text:s text:c="6" />
datePretty[i] = prettyFormat.format(date);
</text:p>
<text:p text:style-name="Code">
<text:s text:c="6" />
dateStamp[i] = stampFormat.format(date);
</text:p>
<text:p text:style-name="Code">
<text:s text:c="6" />
// If this value for 'date' is equal to today, then set the previous
</text:p>
<text:p text:style-name="Code">
<text:s text:c="6" />
// day as the maximum viewable date, because it means the season is
</text:p>
<text:p text:style-name="Code">
<text:s text:c="6" />
// still ongoing. The previous day is used because unless it is late
</text:p>
<text:p text:style-name="Code">
<text:s text:c="6" />
// in the evening, the updated numbers for the day will be unavailable
</text:p>
<text:p text:style-name="Code">
<text:s text:c="6" />
// or incomplete.
</text:p>
<text:p text:style-name="Code">
<text:s text:c="6" />
if (dateStamp[i].equals(todayDateStamp)) {
</text:p>
<text:p text:style-name="Code">
<text:s text:c="8" />
maxDateIndex = i-1;
</text:p>
<text:p text:style-name="Code">
<text:s text:c="6" />
}
</text:p>
<text:p text:style-name="Code">
<text:s text:c="4" />
}
</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
} catch (ParseException e) {
</text:p>
<text:p text:style-name="Code">
<text:s text:c="4" />
die("Problem while setting up dates", e);
</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
}
</text:p>
<text:p text:style-name="Code">
}
</text:p>
<text:p text:style-name="Code">

</text:p>
<text:p text:style-name="Code">

</text:p>
<text:p text:style-name="Code">
// . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
</text:p>
<text:p text:style-name="Code">

</text:p>
<text:p text:style-name="Code">

</text:p>
<text:p text:style-name="Code">
public void setup() {
</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
size(480, 750);
</text:p>
<text:p text:style-name="Code">
<text:s text:c="4" />

</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
setupTeams();
</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
setupDates();
</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
setupSalaries();
</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
// Load the standings after the salaries, because salary
</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
// will be used as the tie-breaker when sorting.
</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
setupStandings();
</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
setupRanking();
</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
setupLogos();
</text:p>
<text:p text:style-name="Code">
<text:s text:c="4" />

</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
font = createFont("Georgia", 12);
</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
textFont(font);
</text:p>
<text:p text:style-name="Code">

</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
frameRate(15);
</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
// Use today as the current day
</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
setDate(maxDateIndex);
</text:p>
<text:p text:style-name="Code">
}
</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />

</text:p>
<text:p text:style-name="Code">

</text:p>
<text:p text:style-name="Code">
void setupTeams() {
</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
String[] lines = loadStrings("teams.tsv");
</text:p>
<text:p text:style-name="Code">
<text:s text:c="4" />

</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
teamCount = lines.length;
</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
teamCodes = new String[teamCount];
</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
teamNames = new String[teamCount];
</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
teamIndices = new HashMap();
</text:p>
<text:p text:style-name="Code">
<text:s text:c="4" />

</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
for (int i = 0; i &lt; teamCount; i++) {
</text:p>
<text:p text:style-name="Code">
<text:s text:c="4" />
String[] pieces = split(lines[i], TAB);
</text:p>
<text:p text:style-name="Code">
<text:s text:c="4" />
teamCodes[i] = pieces[0];
</text:p>
<text:p text:style-name="Code">
<text:s text:c="4" />
teamNames[i] = pieces[1];
</text:p>
<text:p text:style-name="Code">
<text:s text:c="4" />
teamIndices.put(teamCodes[i], new Integer(i));
</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
}
</text:p>
<text:p text:style-name="Code">
}
</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />

</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />

</text:p>
<text:p text:style-name="Code">
int teamIndex(String teamCode) {
</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
Integer index = (Integer) teamIndices.get(teamCode);
</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
return index.intValue();
</text:p>
<text:p text:style-name="Code">
}
</text:p>
<text:p text:style-name="Code">

</text:p>
<text:p text:style-name="Code">

</text:p>
<text:p text:style-name="Code">
void setupSalaries() {
</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
String[] lines = loadStrings("salaries.tsv");
</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
salaries = new SalaryList(lines);
</text:p>
<text:p text:style-name="Code">
}
</text:p>
<text:p text:style-name="Code">

</text:p>
<text:p text:style-name="Code">

</text:p>
<text:p text:style-name="Code">
void setupStandings() {
</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
String[] lines = loadStrings("http://benfry.com/book/salaryper/mlb.cgi");
</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
int dataCount = lines.length / teamCount;
</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
int expectedCount = (maxDateIndex - minDateIndex) + 1;
</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
if (dataCount &lt; expectedCount) {
</text:p>
<text:p text:style-name="Code">
<text:s text:c="4" />
println("Found " + dataCount + " entries in the data file, " +
</text:p>
<text:p text:style-name="Code">
<text:s text:c="12" />
"but was expecting " + expectedCount + " entries.");
</text:p>
<text:p text:style-name="Code">
<text:s text:c="4" />
maxDateIndex = minDateIndex + dataCount - 1;
</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
}
</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
season = new StandingsList[maxDateIndex + 1];
</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
for (int i = 0; i &lt; dataCount; i++) {
</text:p>
<text:p text:style-name="Code">
<text:s text:c="4" />
String[] portion = subset(lines, i*teamCount, teamCount);
</text:p>
<text:p text:style-name="Code">
<text:s text:c="4" />
season[i+minDateIndex] = new StandingsList(portion);
</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
}
</text:p>
<text:p text:style-name="Code">
}
</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />

</text:p>
<text:p text:style-name="Code">

</text:p>
<text:p text:style-name="Code">
void setupRanking() {
</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
standingsPosition = new Integrator[teamCount];
</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
for (int i = 0; i &lt; teamCodes.length; i++) {
</text:p>
<text:p text:style-name="Code">
<text:s text:c="4" />
standingsPosition[i] = new Integrator(i);
</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
}
</text:p>
<text:p text:style-name="Code">
}
</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />

</text:p>
<text:p text:style-name="Code">

</text:p>
<text:p text:style-name="Code">
void setupLogos() {
</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
logos = new PImage[teamCount];
</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
for (int i = 0; i &lt; teamCount; i++) {
</text:p>
<text:p text:style-name="Code">
<text:s text:c="4" />
logos[i] = loadImage("small/" + teamCodes[i] + ".gif");
</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
}
</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
logoWidth = logos[0].width / 2.0f;
</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
logoHeight = logos[0].height / 2.0f;
</text:p>
<text:p text:style-name="Code">
}
</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />

</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />

</text:p>
<text:p text:style-name="Code">
public void draw() {
</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
background(255);
</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
smooth();
</text:p>
<text:p text:style-name="Code">

</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
drawDateSelector();
</text:p>
<text:p text:style-name="Code">

</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
translate(SIDE_PADDING, TOP_PADDING);
</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />

</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
boolean updated = false;
</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
for (int i = 0; i &lt; teamCount; i++) {
</text:p>
<text:p text:style-name="Code">
<text:s text:c="4" />
if (standingsPosition[i].update()) {
</text:p>
<text:p text:style-name="Code">
<text:s text:c="6" />
updated = true;
</text:p>
<text:p text:style-name="Code">
<text:s text:c="4" />
}
</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
}
</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
if (!updated) {
</text:p>
<text:p text:style-name="Code">
<text:s text:c="4" />
noLoop();
</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
}
</text:p>
<text:p text:style-name="Code">

</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
for (int i = 0; i &lt; teamCount; i++) {
</text:p>
<text:p text:style-name="Code">
<text:s text:c="4" />
float standingsY = standingsPosition[i].value * ROW_HEIGHT + HALF_ROW_HEIGHT;
</text:p>
<text:p text:style-name="Code">

</text:p>
<text:p text:style-name="Code">
<text:s text:c="4" />
image(logos[i], 0, standingsY - logoHeight/2, logoWidth, logoHeight);
</text:p>
<text:p text:style-name="Code">
<text:s text:c="6" />

</text:p>
<text:p text:style-name="Code">
<text:s text:c="4" />
textAlign(LEFT, CENTER);
</text:p>
<text:p text:style-name="Code">
<text:s text:c="4" />
text(teamNames[i], 28, standingsY);
</text:p>
<text:p text:style-name="Code">

</text:p>
<text:p text:style-name="Code">
<text:s text:c="4" />
textAlign(RIGHT, CENTER);
</text:p>
<text:p text:style-name="Code">
<text:s text:c="4" />
fill(128);
</text:p>
<text:p text:style-name="Code">
<text:s text:c="4" />
text(standings.getTitle(i), 150, standingsY);
</text:p>
<text:p text:style-name="Code">

</text:p>
<text:p text:style-name="Code">
<text:s text:c="4" />
float weight = map(salaries.getValue(i),
</text:p>
<text:p text:style-name="Code">
<text:s text:c="23" />
salaries.getMinValue(), salaries.getMaxValue(),
</text:p>
<text:p text:style-name="Code">
<text:s text:c="23" />
0.25f, 6);
</text:p>
<text:p text:style-name="Code">
<text:s text:c="4" />
strokeWeight(weight);
</text:p>
<text:p text:style-name="Code">
<text:s text:c="6" />

</text:p>
<text:p text:style-name="Code">
<text:s text:c="4" />
float salaryY = salaries.getRank(i)*ROW_HEIGHT + HALF_ROW_HEIGHT;
</text:p>
<text:p text:style-name="Code">
<text:s text:c="4" />
if (salaryY &gt;= standingsY) {
</text:p>
<text:p text:style-name="Code">
<text:s text:c="6" />
stroke(33, 85, 156);  // Blue for positive (or equal) difference.
</text:p>
<text:p text:style-name="Code">
<text:s text:c="4" />
} else {
</text:p>
<text:p text:style-name="Code">
<text:s text:c="6" />
stroke(206, 0, 82);   // Red for wasting money.
</text:p>
<text:p text:style-name="Code">
<text:s text:c="4" />
}
</text:p>
<text:p text:style-name="Code">
<text:s text:c="6" />

</text:p>
<text:p text:style-name="Code">
<text:s text:c="4" />
line(160, standingsY, 325, salaryY);
</text:p>
<text:p text:style-name="Code">

</text:p>
<text:p text:style-name="Code">
<text:s text:c="4" />
fill(128);
</text:p>
<text:p text:style-name="Code">
<text:s text:c="4" />
textAlign(LEFT, CENTER);
</text:p>
<text:p text:style-name="Code">
<text:s text:c="4" />
text(salaries.getTitle(i), 335, salaryY);
</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
}
</text:p>
<text:p text:style-name="Code">
}
</text:p>
<text:p text:style-name="Code">

</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />

</text:p>
<text:p text:style-name="Code">
// . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
</text:p>
<text:p text:style-name="Code">

</text:p>
<text:p text:style-name="Code">

</text:p>
<text:p text:style-name="Code">
int dateSelectorX;
</text:p>
<text:p text:style-name="Code">
int dateSelectorY = 30;
</text:p>
<text:p text:style-name="Code">

</text:p>
<text:p text:style-name="Code">
// Draw a series of lines for selecting the date
</text:p>
<text:p text:style-name="Code">
void drawDateSelector() {
</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
dateSelectorX = (width - dateCount*2) / 2;
</text:p>
<text:p text:style-name="Code">

</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
strokeWeight(1);
</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
for (int i = 0; i &lt; dateCount; i++) {
</text:p>
<text:p text:style-name="Code">
<text:s text:c="4" />
int x = dateSelectorX + i*2;
</text:p>
<text:p text:style-name="Code">

</text:p>
<text:p text:style-name="Code">
<text:s text:c="4" />
// If this is the currently selected date, draw it differently
</text:p>
<text:p text:style-name="Code">
<text:s text:c="4" />
if (i == dateIndex) {
</text:p>
<text:p text:style-name="Code">
<text:s text:c="6" />
stroke(0);
</text:p>
<text:p text:style-name="Code">
<text:s text:c="6" />
line(x, 0, x, 13);
</text:p>
<text:p text:style-name="Code">
<text:s text:c="6" />
textAlign(CENTER, TOP);
</text:p>
<text:p text:style-name="Code">
<text:s text:c="6" />
text(datePretty[dateIndex], x, 15);
</text:p>
<text:p text:style-name="Code">

</text:p>
<text:p text:style-name="Code">
<text:s text:c="4" />
} else {
</text:p>
<text:p text:style-name="Code">
<text:s text:c="6" />
// If this is a viewable date, make the line darker
</text:p>
<text:p text:style-name="Code">
<text:s text:c="6" />
if ((i &gt;= minDateIndex) &amp;&amp; (i &lt;= maxDateIndex)) {
</text:p>
<text:p text:style-name="Code">
<text:s text:c="8" />
stroke(128);  // Viewable date
</text:p>
<text:p text:style-name="Code">
<text:s text:c="6" />
} else {
</text:p>
<text:p text:style-name="Code">
<text:s text:c="8" />
stroke(204);  // Not a viewable date
</text:p>
<text:p text:style-name="Code">
<text:s text:c="6" />
}
</text:p>
<text:p text:style-name="Code">
<text:s text:c="6" />
line(x, 0, x, 7);
</text:p>
<text:p text:style-name="Code">
<text:s text:c="4" />
}
</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
}
</text:p>
<text:p text:style-name="Code">
}
</text:p>
<text:p text:style-name="Code">

</text:p>
<text:p text:style-name="Code">

</text:p>
<text:p text:style-name="Code">
void setDate(int index) {
</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
dateIndex = index;
</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
standings = season[dateIndex];
</text:p>
<text:p text:style-name="Code">

</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
for (int i = 0; i &lt; teamCount; i++) {
</text:p>
<text:p text:style-name="Code">
<text:s text:c="4" />
standingsPosition[i].target(standings.getRank(i));
</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
}
</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
// Re-enable the animation loop
</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
loop();
</text:p>
<text:p text:style-name="Code">
}
</text:p>
<text:p text:style-name="Code">

</text:p>
<text:p text:style-name="Code">

</text:p>
<text:p text:style-name="Code">
void mousePressed() {
</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
handleMouse();
</text:p>
<text:p text:style-name="Code">
}
</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />

</text:p>
<text:p text:style-name="Code">
void mouseDragged() {
</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
handleMouse();
</text:p>
<text:p text:style-name="Code">
}
</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />

</text:p>
<text:p text:style-name="Code">
void handleMouse() {
</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
if (mouseY &lt; dateSelectorY) {
</text:p>
<text:p text:style-name="Code">
<text:s text:c="4" />
int date = (mouseX - dateSelectorX) / 2;
</text:p>
<text:p text:style-name="Code">
<text:s text:c="4" />
setDate(constrain(date, minDateIndex, maxDateIndex));
</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
}
</text:p>
<text:p text:style-name="Code">
}
</text:p>
<text:p text:style-name="Code">

</text:p>
<text:p text:style-name="Code">

</text:p>
<text:p text:style-name="Code">
void keyPressed() {
</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
if (key == CODED) {
</text:p>
<text:p text:style-name="Code">
<text:s text:c="4" />
if (keyCode == LEFT) {
</text:p>
<text:p text:style-name="Code">
<text:s text:c="6" />
int newDate = max(dateIndex - 1, minDateIndex);
</text:p>
<text:p text:style-name="Code">
<text:s text:c="6" />
setDate(newDate);
</text:p>
<text:p text:style-name="Code">

</text:p>
<text:p text:style-name="Code">
<text:s text:c="4" />
} else if (keyCode == RIGHT) {
</text:p>
<text:p text:style-name="Code">
<text:s text:c="6" />
int newDate = min(dateIndex + 1, maxDateIndex);
</text:p>
<text:p text:style-name="Code">
<text:s text:c="6" />
setDate(newDate);
</text:p>
<text:p text:style-name="Code">
<text:s text:c="4" />
}
</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
}
</text:p>
<text:p text:style-name="Code">
}
</text:p>
<text:p text:style-name="Code">

</text:p>
<text:p text:style-name="Code">

</text:p>
<text:p text:style-name="Code">
// . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
</text:p>
<text:p text:style-name="Code">

</text:p>
<text:p text:style-name="Code">

</text:p>
<text:p text:style-name="Code">
class SalaryList extends RankedList {
</text:p>
<text:p text:style-name="Code">
<text:s text:c="4" />

</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
SalaryList(String[] lines) {
</text:p>
<text:p text:style-name="Code">
<text:s text:c="4" />
super(teamCount, false);
</text:p>
<text:p text:style-name="Code">
<text:s text:c="4" />

</text:p>
<text:p text:style-name="Code">
<text:s text:c="4" />
for (int i = 0; i &lt; teamCount; i++) {
</text:p>
<text:p text:style-name="Code">
<text:s text:c="6" />
String pieces[] = split(lines[i], TAB);
</text:p>
<text:p text:style-name="Code">
<text:s text:c="8" />

</text:p>
<text:p text:style-name="Code">
<text:s text:c="6" />
// First column is the team 2-3 digit team code.
</text:p>
<text:p text:style-name="Code">
<text:s text:c="6" />
int index = teamIndex(pieces[0]);
</text:p>
<text:p text:style-name="Code">
<text:s text:c="8" />

</text:p>
<text:p text:style-name="Code">
<text:s text:c="6" />
// Second column is the salary as a number.
</text:p>
<text:p text:style-name="Code">
<text:s text:c="6" />
value[index] = parseInt(pieces[1]);
</text:p>
<text:p text:style-name="Code">
<text:s text:c="8" />

</text:p>
<text:p text:style-name="Code">
<text:s text:c="6" />
// Make the title in the format $NN,NNN,NNN
</text:p>
<text:p text:style-name="Code">
<text:s text:c="6" />
int salary = (int) value[index];
</text:p>
<text:p text:style-name="Code">
<text:s text:c="6" />
title[index] = "$" + nfc(salary);
</text:p>
<text:p text:style-name="Code">
<text:s text:c="4" />
}
</text:p>
<text:p text:style-name="Code">
<text:s text:c="4" />
update();
</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
}
</text:p>
<text:p text:style-name="Code">
}
</text:p>
<text:p text:style-name="Code">

</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />

</text:p>
<text:p text:style-name="Code">
// . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
</text:p>
<text:p text:style-name="Code">

</text:p>
<text:p text:style-name="Code">

</text:p>
<text:p text:style-name="Code">
class StandingsList extends RankedList {
</text:p>
<text:p text:style-name="Code">
<text:s text:c="4" />

</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
StandingsList(String[] lines) {
</text:p>
<text:p text:style-name="Code">
<text:s text:c="4" />
super(teamCount, false);
</text:p>
<text:p text:style-name="Code">
<text:s text:c="6" />

</text:p>
<text:p text:style-name="Code">
<text:s text:c="4" />
for (int i = 0; i &lt; teamCount; i++) {
</text:p>
<text:p text:style-name="Code">
<text:s text:c="6" />
String[] pieces = split(lines[i], TAB);
</text:p>
<text:p text:style-name="Code">
<text:s text:c="6" />
int index = teamIndex(pieces[0]);
</text:p>
<text:p text:style-name="Code">
<text:s text:c="6" />
int wins = parseInt(pieces[1]);
</text:p>
<text:p text:style-name="Code">
<text:s text:c="6" />
int losses = parseInt(pieces[2]);
</text:p>
<text:p text:style-name="Code">
<text:s text:c="8" />

</text:p>
<text:p text:style-name="Code">
<text:s text:c="6" />
value[index] = (float) wins / (float) (wins+losses);
</text:p>
<text:p text:style-name="Code">
<text:s text:c="6" />
title[index] = wins + "\u2013" + losses;
</text:p>
<text:p text:style-name="Code">
<text:s text:c="4" />
}
</text:p>
<text:p text:style-name="Code">
<text:s text:c="4" />
update();
</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
}
</text:p>
<text:p text:style-name="Code">

</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
float compare(int a, int b) {
</text:p>
<text:p text:style-name="Code">
<text:s text:c="4" />
// First compare based on the record of both teams
</text:p>
<text:p text:style-name="Code">
<text:s text:c="4" />
float amt = super.compare(a, b);
</text:p>
<text:p text:style-name="Code">
<text:s text:c="4" />
// If the record is not identical, return the difference
</text:p>
<text:p text:style-name="Code">
<text:s text:c="4" />
if (amt != 0) return amt;
</text:p>
<text:p text:style-name="Code">

</text:p>
<text:p text:style-name="Code">
<text:s text:c="4" />
// If records are equal, use salary as tie-breaker.
</text:p>
<text:p text:style-name="Code">
<text:s text:c="4" />
// In this case, a and b are switched, because a higher
</text:p>
<text:p text:style-name="Code">
<text:s text:c="4" />
// salary is a negative thing, unlike the values above.
</text:p>
<text:p text:style-name="Code">
<text:s text:c="4" />
return salaries.compare(a, b);
</text:p>
<text:p text:style-name="Code">
<text:s text:c="2" />
}
</text:p>
<text:p text:style-name="Code">
}
</text:p>
<text:p text:style-name="Heading_20_1">Next Steps</text:p>
<text:p text:style-name="Body_20_Text">
Several directions this can be taken in from here, from adaptations of the current data set, to using other data sets or other types of correlations:
</text:p>
<text:p text:style-name="Body_20_Text">
Expand the data to a longer series 
</text:p>
<text:p text:style-name="Body_20_Text">
Can also expand this to do parallel coordinates (show different variables as columns, not just win loss but other stats)
</text:p>
<text:p text:style-name="Body_20_Text">
etc. etc.
</text:p>
<text:p text:style-name="Body_20_Text">
I think this is something to return to once the other chapters are finished, so that it's clear what needs more coverage.
</text:p>
</office:text>
</office:body>
</office:document-content>
#!/bin/sh

cd work && ./processing && cd ..
