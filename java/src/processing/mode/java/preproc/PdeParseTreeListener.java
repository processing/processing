/* -*- mode: java; c-basic-offset: 2; indent-tabs-mode: nil -*- */
package processing.mode.java.preproc;

import java.io.PrintWriter;
import java.io.StringWriter;
import java.text.SimpleDateFormat;
import java.util.*;

import org.antlr.v4.runtime.BufferedTokenStream;
import org.antlr.v4.runtime.ParserRuleContext;
import org.antlr.v4.runtime.TokenStreamRewriter;
import org.antlr.v4.runtime.misc.Interval;

import processing.app.Preferences;
import processing.app.SketchException;
import processing.core.PApplet;
import processing.mode.java.preproc.PdePreprocessor.Mode;

public class PdeParseTreeListener extends ProcessingBaseListener {

  protected final static String version = "3.0.0";
  
  protected String sketchName;
  protected boolean isTested;
  protected TokenStreamRewriter rewriter;
  
  protected Mode mode = Mode.JAVA;
  protected boolean foundMain;
  
  protected int lineOffset;
  
  protected ArrayList<String> coreImports = new ArrayList<String>();
  protected ArrayList<String> defaultImports = new ArrayList<String>();
  protected ArrayList<String> codeFolderImports = new ArrayList<String>();
  protected ArrayList<String> foundImports = new ArrayList<String>();

  private String indent1 = "";
  private String indent2 = "";
  private String indent3 = "";
  
  protected String sketchWidth;
  protected String sketchHeight;
  protected String sketchRenderer;

  protected boolean hasSettingsMethod;

  protected boolean isSizeValidInGlobal;
  
  protected SketchException sketchException;

  PdeParseTreeListener(BufferedTokenStream tokens, String sketchName) {
    rewriter = new TokenStreamRewriter(tokens);
    this.sketchName = sketchName;
  }
  
  protected void setCodeFolderImports(List<String> codeFolderImports) {
    this.codeFolderImports.clear();
    this.codeFolderImports.addAll(codeFolderImports);
  }
  
  protected void setCoreImports(String[] coreImports) {
    setCoreImports(Arrays.asList(coreImports));
  }
  
  protected void setCoreImports(List<String> coreImports) {
    this.coreImports.clear();
    this.coreImports.addAll(coreImports);
  }
  
  protected void setDefaultImports(String[] defaultImports) {
    setDefaultImports(Arrays.asList(defaultImports));
  }
  
  protected void setDefaultImports(List<String> defaultImports) {
    this.defaultImports.clear();
    this.defaultImports.addAll(defaultImports);
  }
  
  protected void setIndent(int indent) {
    final char[] indentChars = new char[indent];
    Arrays.fill(indentChars, ' ');
    indent1 = new String(indentChars);
    indent2 = indent1 + indent1;
    indent3 = indent2 + indent1;
  }
  
  public void setTested(boolean isTested) {
    this.isTested = isTested;
  }
  
  public boolean foundMain() {
    return foundMain;
  }
  
  public String getOutputProgram() {
    return rewriter.getText();
  }
  
  public PreprocessorResult getResult() throws SketchException {
    return new PreprocessorResult(mode, lineOffset, sketchName, foundImports);
  }
  
  protected boolean reportSketchException(SketchException sketchException) {
    if (this.sketchException == null) {
      this.sketchException = sketchException;
      return true;
    }
    return false;
  }
  
  public SketchException getSketchException() {
    return sketchException;
  }
  
  // ------------------------ writers
  
  protected void writeHeader(PrintWriter header) {       
    if (!isTested) writePreprocessorComment(header);
    writeImports(header);
    if (mode == Mode.STATIC || mode == Mode.ACTIVE) writeClassHeader(header);
    if (mode == Mode.STATIC) writeStaticSketchHeader(header);
  }
  
  protected void writePreprocessorComment(PrintWriter header) {
    incLineOffset(); header.println(String.format(
      "/* autogenerated by Processing preprocessor v%s on %s */",
      version, new SimpleDateFormat("YYYY-MM-dd").format(new Date())));
  }
  
  protected void writeImports(PrintWriter header) {
    writeImportList(header, coreImports);
    writeImportList(header, codeFolderImports);
    writeImportList(header, foundImports);
    writeImportList(header, defaultImports);
  }
  
  protected void writeImportList(PrintWriter header, List<String> imports) {
    writeImportList(header, imports.toArray(new String[0]));
  }
  
  protected void writeImportList(PrintWriter header, String[] imports) {
    for (String importDecl : imports) {
      incLineOffset(); header.println("import " + importDecl + ";");
    }
    if (imports.length > 0) {
      incLineOffset(); header.println();
    }
  }
  
  protected void writeClassHeader(PrintWriter header) {
    incLineOffset(); header.println("public class " + sketchName + " extends PApplet {");
    incLineOffset(); header.println();
  }
  
  protected void writeStaticSketchHeader(PrintWriter header) {
    incLineOffset(); header.println(indent1 + "public void setup() {");
  }
  
  protected void writeFooter(PrintWriter footer) {
    if (mode == Mode.STATIC) writeStaticSketchFooter(footer);
    if (mode == Mode.STATIC || mode == Mode.ACTIVE) {
      writeExtraFieldsAndMethods(footer);
      if (!foundMain) writeMain(footer); 
      writeClassFooter(footer);
    }
  }
  
  protected void writeStaticSketchFooter(PrintWriter footer) {
    footer.println(indent2 +   "noLoop();");
    footer.println(indent1 + "}");
  }

  protected void writeExtraFieldsAndMethods(PrintWriter classBody) {
    // can be overriden

    if (!isSizeValidInGlobal) {
      return;
    }

    if (sketchWidth == null || sketchHeight == null || hasSettingsMethod) {
      return;
    }

    StringJoiner argJoiner = new StringJoiner(",");
    argJoiner.add(sketchWidth);
    argJoiner.add(sketchHeight);
    if (sketchRenderer != null) {
      argJoiner.add(sketchRenderer);
    }

    String settingsBody = String.format("size(%s);", argJoiner.toString());

    classBody.println();
    classBody.println(indent1 + String.format("public void settings() { %s }", settingsBody));
}
  
  protected void writeMain(PrintWriter footer) {
    footer.println();
    footer.println(indent1 + "static public void main(String[] passedArgs) {");
    footer.print  (indent2 +   "String[] appletArgs = new String[] { ");

    { // assemble line with applet args
      if (Preferences.getBoolean("export.application.fullscreen")) {
        footer.print("\"" + PApplet.ARGS_FULL_SCREEN + "\", ");

        String bgColor = Preferences.get("run.present.bgcolor");
        footer.print("\"" + PApplet.ARGS_BGCOLOR + "=" + bgColor + "\", ");

        if (Preferences.getBoolean("export.application.stop")) {
          String stopColor = Preferences.get("run.present.stop.color");
          footer.print("\"" + PApplet.ARGS_STOP_COLOR + "=" + stopColor + "\", ");
        } else {
          footer.print("\"" + PApplet.ARGS_HIDE_STOP + "\", ");
        }
      }
      footer.print("\"" + sketchName + "\"");
    }
    
    footer.println(" };");
    
    footer.println(indent2 +   "if (passedArgs != null) {");
    footer.println(indent3 +     "PApplet.main(concat(appletArgs, passedArgs));");
    footer.println(indent2 +   "} else {");
    footer.println(indent3 +     "PApplet.main(appletArgs);");
    footer.println(indent2 +   "}");
    footer.println(indent1 + "}");
  }
  
  protected void writeClassFooter(PrintWriter footer) {
    footer.println("}");
  }

  // --------------------------------------------------- listener impl
  
  /**
   * Wrap the sketch code inside a class definition and
   * add all imports found to the top incl. the default ones
   */
  public void exitProcessingSketch(ProcessingParser.ProcessingSketchContext ctx) {
    { // header
      StringWriter headerSW = new StringWriter();
      PrintWriter headerPW = new PrintWriter(headerSW);
      writeHeader(headerPW);
      rewriter.insertBefore(0, headerSW.getBuffer().toString());
    }

    { // footer
      StringWriter footerSW = new StringWriter();
      PrintWriter footerPW = new PrintWriter(footerSW);
      footerPW.println();
      writeFooter(footerPW);
      rewriter.insertAfter(rewriter.getTokenStream().size(), footerSW.getBuffer().toString());
    }
  }

  protected void incLineOffset() {
    lineOffset++;
  }

  public void exitApiSizeFunction(ProcessingParser.ApiSizeFunctionContext ctx) {
    // this tree climbing could be avoided if grammar is
    // adjusted to force context of size()

    ParserRuleContext testCtx =
      ctx.getParent() // apiFunction
      .getParent() // expression
      .getParent() // statementExpression
      .getParent() // statement
      .getParent() // blockStatement
      .getParent(); // block or staticProcessingSketch

    boolean isInGlobal =
      testCtx instanceof ProcessingParser.StaticProcessingSketchContext;

    isSizeValidInGlobal = false;

    if (isInGlobal) {
      isSizeValidInGlobal = true;
      sketchWidth = ctx.getChild(2).getText();
      if (PApplet.parseInt(sketchWidth, -1) == -1 &&
          !sketchWidth.equals("displayWidth")) {
        isSizeValidInGlobal = false;
      }
      sketchHeight = ctx.getChild(4).getText();
      if (PApplet.parseInt(sketchHeight, -1) == -1 &&
          !sketchHeight.equals("displayHeight")) {
        isSizeValidInGlobal = false;
      }
      if (ctx.getChildCount() > 6) {
        sketchRenderer = ctx.getChild(6).getText();
        if (!(sketchRenderer.equals("P2D") ||
              sketchRenderer.equals("P3D") ||
              sketchRenderer.equals("OPENGL") ||
              sketchRenderer.equals("JAVA2D") ||
              sketchRenderer.equals("FX2D"))) {
          isSizeValidInGlobal = false;
        }
      }
      if (isSizeValidInGlobal) {
        // TODO: uncomment if size is supposed to be removed from setup()
        rewriter.insertBefore(ctx.start, "/* commented out by preprocessor: ");
        rewriter.insertAfter(ctx.stop, " */");
      }
    }
  }
  
  /**
   * Find sketch methods
   */
  public void exitApiMethodDeclaration(ProcessingParser.ApiMethodDeclarationContext ctx) {
    String methodName = ctx.getChild(1).getText();
    if      (methodName.equals("settings"   )) hasSettingsMethod = true;
  }

  /**
   * Remove import declarations, they will be included in the header.
   */
  public void exitImportDeclaration(ProcessingParser.ImportDeclarationContext ctx) {
    rewriter.delete(ctx.start, ctx.stop);
  }
  
  /**
   * Save qualified import name (with static modifier when present)
   * for inclusion in the header.
   */
  public void exitImportString(ProcessingParser.ImportStringContext ctx) {
    Interval interval =
      new Interval(ctx.start.getStartIndex(), ctx.stop.getStopIndex());
    String importString = ctx.start.getInputStream().getText(interval);
    foundImports.add(importString);
  }

  /**
   * Any floating point number that has not float / double suffix
   * will get a 'f' appended to make it float.
   */
  public void exitDecimalfloatingPointLiteral(ProcessingParser.DecimalfloatingPointLiteralContext ctx) {
    String cTxt = ctx.getText().toLowerCase();
    if (!cTxt.endsWith("f") && !cTxt.endsWith("d")) {
      rewriter.insertAfter(ctx.stop, "f");
    }
  }

  /**
   * Detect "static sketches"
   */
  public void exitStaticProcessingSketch(ProcessingParser.StaticProcessingSketchContext ctx) {
    mode = Mode.STATIC;
  }
  
  /**
   * Detect "active sketches"
   */
  public void exitActiveProcessingSketch(ProcessingParser.ActiveProcessingSketchContext ctx) {
    mode = Mode.ACTIVE;
  }

  /**
   * Make any method "public" that has:
   * - no other access modifier
   * - return type "void"
   * - is either in the context of the sketch class
   * - or is in the context of a class definition that extends PApplet
   */
  public void exitMethodDeclaration(ProcessingParser.MethodDeclarationContext ctx) {
    ParserRuleContext memCtx = ctx.getParent();
    ParserRuleContext clsBdyDclCtx = memCtx.getParent();
    ParserRuleContext clsBdyCtx = clsBdyDclCtx.getParent();
    ParserRuleContext clsDclCtx = clsBdyCtx.getParent();

    boolean inSketchContext = 
      clsBdyCtx instanceof ProcessingParser.StaticProcessingSketchContext ||
      clsBdyCtx instanceof ProcessingParser.ActiveProcessingSketchContext;

    boolean inPAppletContext =
      inSketchContext || (
        clsDclCtx instanceof ProcessingParser.ClassDeclarationContext &&
        clsDclCtx.getChildCount() >= 4 && 
        clsDclCtx.getChild(2).getText().equals("extends") &&
        clsDclCtx.getChild(3).getText().endsWith("PApplet"));

    boolean voidType = ctx.getChild(0).getText().equals("void");

    // not the first, so no mod before
    boolean hasModifier = clsBdyDclCtx.getChild(0) != memCtx;

    if (!hasModifier && inPAppletContext && voidType) {
      rewriter.insertBefore(memCtx.start, "public ");
    }

    if ((inSketchContext || inPAppletContext) && 
        hasModifier && 
        ctx.getChild(1).getText().equals("main")) {
      foundMain = true;
    }
  }

  /**
   * Change any "value converters" with the name of a primitive type
   * to their proper names:
   * int() --> parseInt()
   * float() --> parseFloat()
   * ...
   */
  public void exitFunctionWithPrimitiveTypeName(ProcessingParser.FunctionWithPrimitiveTypeNameContext ctx) {
    String fn = ctx.getChild(0).getText();
    if (!fn.equals("color")) {
      fn = "PApplet.parse" + fn.substring(0,1).toUpperCase() + fn.substring(1);
      rewriter.insertBefore(ctx.start, fn);
      rewriter.delete(ctx.start);
    }
  }

  /**
   * Fix "color type" to be "int".
   */
  public void exitColorPrimitiveType(ProcessingParser.ColorPrimitiveTypeContext ctx) {
    if (ctx.getText().equals("color")) {
      rewriter.insertBefore(ctx.start, "int");
      rewriter.delete(ctx.start, ctx.stop);
    }
  }

  /**
   * Fix hex color literal
   */
  public void exitHexColorLiteral(ProcessingParser.HexColorLiteralContext ctx) {
    rewriter.insertBefore(ctx.start, ctx.getText().toUpperCase().replace("#","0xFF"));
    rewriter.delete(ctx.start, ctx.stop);
  }
}